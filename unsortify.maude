--- name: unsortify.maude
--- reqs: prelude.maude (META-LEVEL), prelude-aux.maude (QIDPAIRSET,OPDECLSET-EXTRA) full-maude.maude (UNIT)
--- note: This file implements two functions:
---       [1] unsortify(Module)     --- returns a Module with a single sort
---       [2] sortify(Term,TermSet) --- takes constants in a term that are unsorted and sorts them
---       unsortify() requires that the module to transformed has no:
---         [a] imports (can be achieved by module transformation)
---         [b] conditional equations
---         [c] memberships
---         [d] associative/id axioms
---       sortify() requires TermSet is actually a ConstantSet

fmod UNSORTIFY is
  pr META-LEVEL .
  pr ATTR-EXTRA .
  pr TOP-MODULE .
  pr QID-JOIN .

  op unsortify       : Module                   -> [Module] .
  op unsortify       : Module OpDeclSet         -> [OpDeclSet] .
  op unsortify       : Module EquationSet       -> EquationSet .
  op unsortify       : TypeList                 -> TypeList .
  op unsortify       : Module Condition         -> Condition .
  op unsortify       : Module Term              -> Term .
  op unsortify       : Module TermList TermList -> TermList .
  op unsortify-codom : Module Substitution      -> Substitution .
  op unsortify-qids  : Module QidSet            -> QidSet .
  op unsortify-safe  : AttrSet                  -> Bool .

  var H  : Header    . var SS : SortSet . var SDS : SubsortDeclSet .
  var OS : OpDeclSet . var ES : EquationSet . var RLS : RuleSet . var M : Module .
  var TY : Type . var TYL : TypeList . var V : Variable . var C : Constant .
  var Q : Qid . var T T' : Term . var NL : NeTermList . var TL TL' : TermList .
  var TQ : TermQid . var QS : QidSet . var S : Substitution . var AS : AttrSet .
  var D : EqCondition .

  eq unsortify(M) =
    setSubsorts(setEqs(setOps(setSorts(M,'U),unsortify(M,getOps(M))),unsortify(M,getEqs(M))),none) .

 ceq unsortify(M,op Q : TYL -> TY [AS]. OS)=
   if TYL == nil
     then op usn(M,Q,TY) : nil -> 'U [AS].
     else op Q : unsortify(TYL) -> 'U [AS].
   fi unsortify(M,OS)
  if unsortify-safe(AS) .
  eq unsortify(M,(none).OpDeclSet)         = (none).OpDeclSet .
  eq unsortify(M,eq T = T' [AS]. ES)       = eq unsortify(M,T) = unsortify(M,T') [AS]. unsortify(M,ES) .
  eq unsortify(M,ceq T = T' if D [AS]. ES) = ceq unsortify(M,T) = unsortify(M,T') if unsortify(M,D) [AS]. unsortify(M,ES) .
  eq unsortify(M,(none).EquationSet)       = (none).EquationSet .

  eq unsortify(TY TYL)                    = 'U unsortify(TYL) .
  eq unsortify(nil)                       = nil .
  eq unsortify(M,V)                       = join(usn(M,getName(V),getType(V)) ':U) .
  eq unsortify(M,C)                       = join(usn(M,getName(C),getType(C)) '.U) .
  eq unsortify(M,Q[NL])                   = Q[unsortify(M,NL,empty)] .
  eq unsortify(M,(T,TL),TL')              = unsortify(M,TL,(TL',unsortify(M,T))) .
  eq unsortify(M,empty,NL)                = NL .

  eq unsortify(M,D)                       = nil .

  eq unsortify-codom(M,V <- T ; S)        = V <- unsortify(M,T) ; unsortify-codom(M,S) .
  eq unsortify-codom(M,none)              = none .

  eq unsortify-qids(M,TQ ; QS)            = unsortify(M,TQ) ; unsortify-qids(M,QS) .
  eq unsortify-qids(M,none)               = none .

  eq unsortify-safe(id(T) AS)             = false .
  eq unsortify-safe(right-id(T) AS)       = false .
  eq unsortify-safe(left-id(T) AS)        = false .
  eq unsortify-safe(AS)                   = true  . --- in(assoc,AS) implies in(comm,AS) .

  op usn : Module Qid Type -> Qid .
  eq usn(M,Q,TY) = join(Q k2s-map#(M,TY)) .
endfm

fmod SORTIFY is
  pr META-LEVEL .
  pr OPDECLSET-EXTRA .
  pr QIDTUPLESET .
  pr UNSORTIFY .

  op sortify        : Term              QidPairSet -> Term .
  op sortify'       : Term              QidPairSet -> Term .
  op sortify'       : TermList TermList QidPairSet -> Term .
  --- create qidpairset from module for use with sortify
  op constsToQTS    : Module                         -> QidPairSet .
  op constsToQTS    : Module OpDeclSet               -> QidPairSet .

  var T  : Term . var NL   : NeTermList . var TL TL' : TermList . var TQ : TermQid .
  var Q K : Qid  . var C C' : Constant   . var V      : Variable .
  var QS : QidPairSet . var S : Sort . var OD : OpDecl . var OS : OpDeclSet .
  var VS : QidSet . var M : Module .

  eq sortify (T,QS)          = sortify'(T,QS) .
  eq sortify'(TQ,QS)         = applyQPS!(getName(TQ),QS) .
  eq sortify'(Q[NL],QS)      = Q[sortify'(NL,empty,QS)] .
  eq sortify'((T,TL),TL',QS) = sortify'(TL,(TL',sortify'(T,QS)),QS) .
  eq sortify'(empty,NL,QS)   = NL .

  eq constsToQTS(M)           = constsToQTS(M,constants(getOps(M))) .
  eq constsToQTS(M,OD OS)     = qp(usn(M,qid(OD),resultType(OD)),join(qid(OD) '. resultType(OD))) | constsToQTS(M,OS) .
  eq constsToQTS(M,none)      = none .
endfm

fmod SORTIFY-AUX is
   pr SORTIFY .
   pr META-LEVEL .

   op sortify  : EquationSet QidPairSet -> EquationSet .
   op sortify' : EquationSet QidPairSet -> EquationSet .
   var T T' : Term . var AS : AttrSet . var ES : EquationSet . var QS : QidPairSet .
   eq sortify(ES,QS) = sortify'(ES,QS) .
   eq sortify'(eq T = T' [AS]. ES,QS) = (eq sortify'(T,QS) = sortify'(T',QS) [AS].) sortify'(ES,QS) .
   eq sortify'((none).EquationSet,QS) = (none).EquationSet .
endfm

--- Complete solution for reducing a module into a many-sorted one
--- NOTE: the underlying function is k2s-map#() which lifts a type
---       into a unique corresponding sort
fmod MANYSORTIFY is
  pr TOP-MODULE .
  pr META-LEVEL .
  pr QID-JOIN   .
  pr ATTR-EXTRA .

  var M : Module .
  var TY : Type .
  var TYL : TypeList .
  var ODS : OpDeclSet .
  var EQS : EquationSet .
  var RLS : RuleSet .
  var AS : AttrSet .
  var T T' : Term .
  var TL : TermList .
  var NTL : NeTermList .
  var S : Sort .
  var ECnD : EqCondition .
  var CnD : Condition .
  var HL : HookList .
  var Q Q' : Qid .
  var QL : QidList .
  var QS : QidSet .
  var C : Constant .
  var V : Variable .
  var TQ : TermQid .
  var N N' : Nat .
  var NL : NatList .
  var NNL : NeNatList .
  var QPS : QidPairSet .

  op manysortify : Module -> Module [memo] .
  op manysortify : Module OpDeclSet -> OpDeclSet .
  op manysortify : Module EquationSet -> EquationSet .
  op manysortify : Module RuleSet -> RuleSet .
  op manysortify : Module Condition -> Condition .
  op manysortify : Module TermList -> TermList .
  op manysortify : Module AttrSet -> AttrSet .
  op manysortify : Module HookList -> HookList .
  op manysortify : Module QidSet -> QidSet .
  op manysortify : Module TermQid -> TermQid .
  --- handles poly() operators
  op manysortify : Module Nat NatList TypeList -> TypeList .

  --- inverse transform intermediate data struct
  op ordersortify-table : Module -> QidPairSet .
  op ordersortify-table : Module OpDeclSet QidPairSet -> QidPairSet .

  eq manysortify(M) =
    setRls(
      setEqs(
        setOps(
	  setSubsorts(
            setSorts(M,p2QPS(k2s-map#(M))),
	    none),
          manysortify(M,getOps(M))),
        manysortify(M,getEqs(M))),
      manysortify(M,getRls(M))) .

  eq manysortify(M,op Q : TYL -> TY [poly(NNL) AS]. ODS) =
    if last(NNL) == 0 then
      (op Q : manysortify(M,1,front(NNL),TYL) -> 'Universal     [poly(NNL) manysortify(M,AS)].)
    else
      (op Q : manysortify(M,1,NNL,TYL)        -> k2s-map#(M,TY) [poly(NNL) manysortify(M,AS)].)
    fi
    manysortify(M,ODS) .
  eq manysortify(M,op Q : TYL -> TY [AS]. ODS) =
    (op Q : k2s-map#(M,TYL) -> k2s-map#(M,TY) [manysortify(M,AS)].)
    manysortify(M,ODS) [owise] .
  eq manysortify(M,(none).OpDeclSet) = none .

  eq manysortify(M,eq T = T' [AS]. EQS) =
    (eq manysortify(M,T) = manysortify(M,T') [AS] .)
    manysortify(M,EQS) .
  eq manysortify(M,ceq T = T' if ECnD [AS]. EQS) =
    (ceq manysortify(M,T) = manysortify(M,T') if manysortify(M,ECnD) [AS] .)
    manysortify(M,EQS) .
  eq manysortify(M,(none).EquationSet) = none .

  eq manysortify(M,rl T => T' [AS]. RLS) =
    (rl manysortify(M,T) => manysortify(M,T') [AS] .)
    manysortify(M,RLS) .
  eq manysortify(M,crl T => T' if CnD [AS]. RLS) =
    (crl manysortify(M,T) => manysortify(M,T') if manysortify(M,CnD) [AS] .)
    manysortify(M,RLS) .
  eq manysortify(M,(none).RuleSet) = none .

  eq manysortify(M,T = T' /\ CnD) =
    manysortify(M,T) = manysortify(M,T') /\
    manysortify(M,CnD) .
  eq manysortify(M,T := T' /\ CnD) =
    manysortify(M,T) := manysortify(M,T') /\
    manysortify(M,CnD) .
  eq manysortify(M,T : S /\ CnD) =
    manysortify(M,T) := k2s-map#(M,S) /\
    manysortify(M,CnD) .
  eq manysortify(M,T => T' /\ CnD) =
    manysortify(M,T) := manysortify(M,T') /\
    manysortify(M,CnD) .
  eq manysortify(M,(nil).EqCondition) = nil .

  eq manysortify(M,C)      = qid(string(getName(C)) + "." + string(k2s-map#(M,getType(C)))) .
  eq manysortify(M,V)      = qid(string(getName(V)) + ":" + string(k2s-map#(M,getType(V)))) .
  eq manysortify(M,Q[NTL]) = Q[manysortify(M,NTL)] .
  eq manysortify(M,(T,TL)) = manysortify(M,T),manysortify(M,TL) .
  eq manysortify(M,empty)  = empty .

  eq manysortify(M,id(T) AS)       = id(manysortify(M,T)) manysortify(M,AS) .
  eq manysortify(M,left-id(T) AS)  = left-id(manysortify(M,T)) manysortify(M,AS) .
  eq manysortify(M,right-id(T) AS) = right-id(manysortify(M,T)) manysortify(M,AS) .
  eq manysortify(M,special(HL) AS) = special(manysortify(M,HL)) manysortify(M,AS) .
  eq manysortify(M,AS)             = AS [owise] .

  eq manysortify(M,term-hook(Q,T) HL) =
    term-hook(Q,manysortify(M,T))
    manysortify(M,HL) .
  eq manysortify(M,op-hook(Q,Q',TYL,TY) HL) =
    op-hook(Q,Q',k2s-map#(M,TYL),k2s-map#(M,TY))
    manysortify(M,HL) .
  eq manysortify(M,id-hook(Q,QL) HL) =
    id-hook(Q,QL)
    manysortify(M,HL) .
  eq manysortify(M,(nil).HookList) = nil .

  --- handles poly() operators
  eq manysortify(M,N,N' NL,TY TYL) =
    if N == N'
      then 'Universal manysortify(M,s(N),NL,TYL)
      else k2s-map#(M,TY) manysortify(M,s(N),N' NL,TYL)
    fi .
  eq manysortify(M,N,nil,TYL) = k2s-map#(M,TYL) .
  eq manysortify(M,N,nil,nil) = nil .

  eq manysortify(M,TQ ; QS) = manysortify(M,TQ) ; manysortify(M,QS) .
  eq manysortify(M,(none).QidSet) = (none).QidSet .

  eq ordersortify-table(M) = ordersortify-table(M,getOps(M),none) .
  eq ordersortify-table(M,op Q : TYL -> TY [AS]. ODS,QPS) =
    ordersortify-table(M,ODS,QPS |
      if in(poly-attr,AS) or TYL =/= nil
        then none
	else qp(join(Q '. k2s-map#(M,TY)),join(Q '. TY))
      fi) .
  eq ordersortify-table(M,(none).OpDeclSet,QPS) = QPS .
endfm
