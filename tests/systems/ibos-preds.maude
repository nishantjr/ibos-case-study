load ../../systems/ibos.maude

---
--- [PARTIALLY] FVP
---

---
--- 1. Separate ProcessIds into Net/WebProcs and everything else
---
fmod PROC-ID-FVP-EXT is
  pr PROC-ID .

  --- 1. Separate ProcessIds into Net/WebProcs and everything else
  sort ConcNetWebProcId .
  subsort ConcNetProcId ConcWebProcId < ConcNetWebProcId < ConcPipeId .
  sort NonConcNetWebProcId .
  subsort UIId NonPipeId < NonConcNetWebProcId .
endfm

---
--- 2. Separate Configurations into those made up of Net/WebProcs and everything else
--- 3. Add partially FVP predicate for checking if an object with the named ID is in the configuration
--- 4. Add partially FVP predicate for checking for duplicate object IDs in the configuration
---
fmod CONFIGURATION-FVP-EXT is
  pr PROC-ID-FVP-EXT .
  pr KERNEL-POLICIES-FVP .

  var P P' : ConcProcId . var A A' : AttributeSet . var C : Configuration .
  var P? : ProcessId .

  --- 2. Separate Configurations into those made up of Net/WebProcs and everything else
  sorts NetWebProcObject NetWebProcConfig NetWebProcNeConfig .
  subsort NetWebProcObject < Object .
  subsort NetWebProcObject < NetWebProcNeConfig < NeConfiguration NetWebProcConfig < Configuration .
  subsort EmptyConfiguration < NetWebProcConfig .
  op <_|_> : ConcNetWebProcId AttributeSet -> NetWebProcObject [ctor ditto metadata "35"] .
  op __ : NetWebProcConfig   NetWebProcConfig -> NetWebProcConfig   [ctor ditto metadata "37"] .
  op __ : NetWebProcNeConfig NetWebProcConfig -> NetWebProcNeConfig [ctor ditto metadata "37"] .

  sorts SpecialObject SpecialConfig SpecialNeConfig .
  subsort SpecialObject < Object .
  subsort SpecialObject < SpecialNeConfig < NeConfiguration SpecialConfig < Configuration .
  subsort EmptyConfiguration < SpecialConfig .
  op <_|_> : NonConcNetWebProcId AttributeSet -> SpecialObject [ctor ditto metadata "35"] .
  op __ : SpecialConfig   SpecialConfig -> SpecialConfig   [ctor ditto metadata "37"] .
  op __ : SpecialNeConfig SpecialConfig -> SpecialNeConfig [ctor ditto metadata "37"] .
endfm

---
--- 5. Add LabelPair and MaybeLabelPair datatypes
--- 6. Add MaybeLabelPair equality predicate _~lp_
--- 7. Add LabelPair projection functions
--- 8. Add _blank-or-equal_ function
---
fmod LABEL-FVP-EXT is
  pr LABEL .

  var L L' : Label .
  var N : Nat .
  var P : NzNat .
  var L1 L2 L1' L2' : MaybeLabel .
  var MMLP : MaybeMaybeLabel+Pair .
  var MLP : MaybeLabelPair .

  sort BlankLabel NonBlankLabel .
  subsort BlankLabel NonBlankLabel < Label .
  op about-blank : -> BlankLabel        [ctor ditto metadata "40"] .
  op url         : Nat -> NonBlankLabel [ctor ditto metadata "41"] .

  --- 5. Add LabelPair and MaybeLabelPair datatypes
  sort LabelPair MaybeLabelPair MaybeLabel+Pair MaybeMaybeLabel+Pair .
  subsort LabelPair < MaybeLabelPair  < MaybeMaybeLabel+Pair .
  subsort LabelPair < MaybeLabel+Pair < MaybeMaybeLabel+Pair .
  op nopair  :                       -> MaybeLabelPair       [ctor metadata "89"] .
  op ((_,_)) : Label Label           -> LabelPair            [ctor metadata "90"] .
  op ((_,_)) : MaybeLabel MaybeLabel -> MaybeMaybeLabel+Pair [ctor metadata "90"] .

  --- 6. Add MaybeLabelPair equality predicate _~lp_
  op _~lp_ : MaybeMaybeLabel+Pair MaybeMaybeLabel+Pair -> Bool [comm metadata "91"] .
  eq MMLP         ~lp MMLP      = true                    [variant] .
  eq (L1,L2)      ~lp (L1',L2') = L1 ~l L1' and L2 ~l L2' [variant] .
  eq nopair       ~lp (L1, L2 ) = false                   [variant] .
  eq (nolabel,L2) ~lp MLP       = false                   [variant] .
  eq (L1,nolabel) ~lp MLP       = false                   [variant] .

  op outlbl : MaybeLabelPair -> MaybeLabel [metadata "93"] .
  eq outlbl((L1,L2)) = L2      [variant] .
  eq outlbl(nopair)  = nolabel [variant] .

  --- 8. Add _blank-or-equal_ function
  op _blank-or-equal_ : Label Label -> Bool [metadata "94"] .
  eq about-blank blank-or-equal L           = true  [variant] .
  eq L           blank-or-equal L           = true  [variant] .
  eq url(N)      blank-or-equal about-blank = false [variant] .
  eq url(N)      blank-or-equal url(N + P)  = false [variant] .
  eq url(N + P)  blank-or-equal url(N)      = false [variant] .
endfm

---
--- 9. Refine MsgType/Msg into subsorts for each kind of message
--- 10. Refine MessageList into empty and non-empty variants
--- 11. Refine MessageList into those with a FETCH message and those without
--- 13. Add predicate that returns false iff a MessageList contains a NEW-URL message with a given label
---
fmod MSG-FVP-EXT is
  pr MSG-LIST .

  var PI PI' : PipeId .
  var L OUT : Label .
  var ML ML2 : MessageList .
  var RetMT : RetMsgType .
  var FetchMT : FetchMsgType .

  --- 9. Refine MsgType/Msg into subsorts for each kind of message
  sort FetchMsgType RetMsgType NonRetFetchMsgType NonRetMsgType NonFetchMsgType .
  subsort NonRetFetchMsgType < NonRetMsgType NonFetchMsgType < MsgType .
  subsort FetchMsgType < NonRetMsgType .
  subsort RetMsgType   < NonFetchMsgType .
  op MSG-NEW-URL    : -> NonRetFetchMsgType [ctor metadata "48"] .
  op MSG-FETCH-URL  : -> FetchMsgType       [ctor metadata "49"] .
  op MSG-RETURN-URL : -> RetMsgType         [ctor metadata "50"] .
  op MSG-SWITCH-TAB : -> NonRetFetchMsgType [ctor metadata "51"] .
  ----------------------------------------------------
  eq MSG-RETURN-URL ~m M:NonRetMsgType   = false .
  eq MSG-FETCH-URL  ~m M:NonFetchMsgType = false .

  sort NonRetFetchMsg FetchMsg RetMsg NonRetMsg NonFetchMsg .
  subsort NonRetFetchMsg < NonRetMsg NonFetchMsg < Message .
  subsort FetchMsg < NonRetMsg .
  subsort RetMsg   < NonFetchMsg .
  op msg : PipeId PipeId FetchMsgType       Label -> FetchMsg       [ctor ditto metadata "52"] .
  op msg : PipeId PipeId RetMsgType         Label -> RetMsg         [ctor ditto metadata "52"] .
  op msg : PipeId PipeId NonFetchMsgType    Label -> NonFetchMsg    [ctor ditto metadata "52"] .
  op msg : PipeId PipeId NonRetMsgType      Label -> NonRetMsg      [ctor ditto metadata "52"] .
  op msg : PipeId PipeId NonRetFetchMsgType Label -> NonRetFetchMsg [ctor ditto metadata "52"] .

  --- 10. Refine MessageList into empty and non-empty variants
  sort EmptyMessageList .
  subsort EmptyMessageList < MessageList .
  op mt  : -> EmptyMessageList [ctor ditto metadata "5"] .
  op _@_ : EmptyMessageList EmptyMessageList -> EmptyMessageList [ctor ditto metadata "54"] .

  sort NeMessageList .
  subsort Message < NeMessageList < MessageList .
  op _@_ : NeMessageList MessageList -> NeMessageList [ctor ditto metadata "54"] .
  op _@_ : MessageList NeMessageList -> NeMessageList [ctor ditto metadata "54"] .

  --- 11. Refine MessageList into those with a FETCH message and those without
  sort NonFetchMsgList NeNonFetchMsgList HasFetchMsgList .
  subsort EmptyMessageList < NonFetchMsgList < MessageList .
  subsort NonFetchMsg < NeNonFetchMsgList < NonFetchMsgList NeMessageList .
  subsort FetchMsg < HasFetchMsgList < NeMessageList .
  op _@_ : NonFetchMsgList NeNonFetchMsgList -> NeNonFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : NeNonFetchMsgList NonFetchMsgList -> NeNonFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : NonFetchMsgList NonFetchMsgList -> NonFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : NonFetchMsgList HasFetchMsgList -> HasFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : HasFetchMsgList NonFetchMsgList -> HasFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : HasFetchMsgList HasFetchMsgList -> HasFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : MessageList     HasFetchMsgList -> HasFetchMsgList [ctor ditto metadata "54"] .
  op _@_ : HasFetchMsgList MessageList     -> HasFetchMsgList [ctor ditto metadata "54"] .

  --- 13. Add predicate that returns false iff a MessageList contains a NEW-URL message with a given label
  --- NB: this is an auxiliary predicate for ui-consistent
  op newurl-nodupl? : Label MessageList -> Bool [metadata "198 false"] .
  eq newurl-nodupl?(L,ML @ msg(PI,PI',MSG-NEW-URL,   L)   @ ML2) = false [variant] .
 ceq newurl-nodupl?(L,ML @ msg(PI,PI',MSG-NEW-URL,   OUT) @ ML2) = newurl-nodupl?(L,ML @ ML2) if L ~l OUT = false .
  eq newurl-nodupl?(L,ML @ msg(PI,PI',RetMT,         OUT) @ ML2) = newurl-nodupl?(L,ML @ ML2) .
  eq newurl-nodupl?(L,ML @ msg(PI,PI',FetchMT,       OUT) @ ML2) = newurl-nodupl?(L,ML @ ML2) .
  eq newurl-nodupl?(L,ML @ msg(PI,PI',MSG-SWITCH-TAB,OUT) @ ML2) = newurl-nodupl?(L,ML @ ML2) .
  eq newurl-nodupl?(L,mt)                                        = true .

  op noRetMsg? : MessageList -> Bool [metadata "195 false"] .
  eq noRetMsg?(ML @ R:RetMsg     @ ML2) = false [variant] .
  eq noRetMsg?(ML @ NR:NonRetMsg @ ML2) = noRetMsg?(ML @ ML2) .
  eq noRetMsg?(mt)                      = true .
endfm

---
--- 14. Refine Net/WebProcInfoSet into empty and non-empty variants
--- 15. Add Net/WebProcInfo equality predicates
--- 16. Add partially FVP predicates for checking if a ProcessId is mapped in a Net/WebProcInfoSet
---
fmod KERNEL-METADATA-FVP-EXT is
  pr KERNEL-POLICIES-FVP .
  pr LABEL-FVP-EXT .

  --- 14. Refine Net/WebProcInfoSet into empty and non-empty variants
  sort NeWebProcInfoSet .
  subsort WebProcInfo < NeWebProcInfoSet < WebProcInfoSet .
  sort NeNetProcInfoSet .
  subsort NetProcInfo < NeNetProcInfoSet < NetProcInfoSet .
  op _,wp_ : NeWebProcInfoSet WebProcInfoSet -> NeWebProcInfoSet [ctor ditto metadata "74"] .
  op _,np_ : NeNetProcInfoSet NetProcInfoSet -> NeNetProcInfoSet [ctor ditto metadata "77"] .
endfm

---
--- 17. Generalize typing of returnTo(), rendered(), fromKernel(), and toKernel() attributes (used for attribute canonicalization)
--- 18. Add attribute type equality predicate _~a_
--- 19. Add partially FVP in-attrset?(_|_) predicate for checking if an attribute of a given type exists in an attribute set
--- 20. Add partially FVP attr-dupl?() predicate for checking if an attribute type occurs twice in a given attribute set
---
fmod ATTRIBUTE-FVP-EXT is
  pr PROC-ID-FVP-EXT .
  pr KERNEL-POLICIES-FVP .
  pr MSG-FVP-EXT .
  var A A' : Attribute . var AS AS' : AttributeSet .

  --- 18. Add attribute type equality predicate _~a_
  op _~a_ : Attribute Attribute -> Bool [comm metadata "100"] .
  eq fromKernel      (X:MessageList)        ~a fromKernel      (Y:MessageList)        = true [variant] .
  eq toKernel        (X:MessageList)        ~a toKernel        (Y:MessageList)        = true [variant] .
  eq nextWPN         (X:Nat)                ~a nextWPN         (Y:Nat)                = true [variant] .
  eq rendered        (X:Label)              ~a rendered        (Y:Label)              = true [variant] .
  eq URL             (X:Label)              ~a URL             (Y:Label)              = true [variant] .
  eq loading         (X:Bool)               ~a loading         (Y:Bool)               = true [variant] .
  eq returnTo        (X:ConcPipeId)         ~a returnTo        (Y:ConcPipeId)         = true [variant] .
  eq in              (X:LabelList)          ~a in              (Y:LabelList)          = true [variant] .
  eq out             (X:LabelList)          ~a out             (Y:LabelList)          = true [variant] .
  eq mem-in          (X:MaybeLabel)         ~a mem-in          (Y:MaybeLabel)         = true [variant] .
  eq mem-out         (X:MaybeLabel)         ~a mem-out         (Y:MaybeLabel)         = true [variant] .
  eq nic-in          (X:LabelList)          ~a nic-in          (Y:LabelList)          = true [variant] .
  eq nic-out         (X:LabelSet)           ~a nic-out         (Y:LabelSet)           = true [variant] .
  eq msgPolicy       (X:PolicySet)          ~a msgPolicy       (Y:PolicySet)          = true [variant] .
  eq nextNPN         (X:Nat)                ~a nextNPN         (Y:Nat)                = true [variant] .
  eq handledCurrently(X:Message?)           ~a handledCurrently(Y:Message?)           = true [variant] .
  eq weblabels       (X:WebProcInfoSet)     ~a weblabels       (Y:WebProcInfoSet)     = true [variant] .
  eq netlabels       (X:NetProcInfoSet)     ~a netlabels       (Y:NetProcInfoSet)     = true [variant] .
  eq displayedTopBar (X:Label)              ~a displayedTopBar (Y:Label)              = true [variant] .
  eq displayedContent(X:Label)              ~a displayedContent(Y:Label)              = true [variant] .
  eq activeWebapp    (X:MaybeConcWebProcId) ~a activeWebapp    (Y:MaybeConcWebProcId) = true [variant] .

  eq fromKernel      (X:MessageList)        ~a toKernel        (Y:MessageList)        = false [variant] .
  eq fromKernel      (X:MessageList)        ~a nextWPN         (Y:Nat)                = false [variant] .
  eq fromKernel      (X:MessageList)        ~a rendered        (Y:Label)              = false [variant] .
  eq fromKernel      (X:MessageList)        ~a URL             (Y:Label)              = false [variant] .
  eq fromKernel      (X:MessageList)        ~a loading         (Y:Bool)               = false [variant] .
  eq fromKernel      (X:MessageList)        ~a returnTo        (Y:ConcPipeId)         = false [variant] .
  eq fromKernel      (X:MessageList)        ~a in              (Y:LabelList)          = false [variant] .
  eq fromKernel      (X:MessageList)        ~a out             (Y:LabelList)          = false [variant] .
  eq fromKernel      (X:MessageList)        ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq fromKernel      (X:MessageList)        ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq fromKernel      (X:MessageList)        ~a nic-in          (Y:LabelList)          = false [variant] .
  eq fromKernel      (X:MessageList)        ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq fromKernel      (X:MessageList)        ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq fromKernel      (X:MessageList)        ~a nextNPN         (Y:Nat)                = false [variant] .
  eq fromKernel      (X:MessageList)        ~a handledCurrently(Y:Message?)           = false [variant] .
  eq fromKernel      (X:MessageList)        ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq fromKernel      (X:MessageList)        ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq fromKernel      (X:MessageList)        ~a displayedTopBar (Y:Label)              = false [variant] .
  eq fromKernel      (X:MessageList)        ~a displayedContent(Y:Label)              = false [variant] .
  eq fromKernel      (X:MessageList)        ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq toKernel        (X:MessageList)        ~a nextWPN         (Y:Nat)                = false [variant] .
  eq toKernel        (X:MessageList)        ~a rendered        (Y:Label)              = false [variant] .
  eq toKernel        (X:MessageList)        ~a URL             (Y:Label)              = false [variant] .
  eq toKernel        (X:MessageList)        ~a loading         (Y:Bool)               = false [variant] .
  eq toKernel        (X:MessageList)        ~a returnTo        (Y:ConcPipeId)         = false [variant] .
  eq toKernel        (X:MessageList)        ~a in              (Y:LabelList)          = false [variant] .
  eq toKernel        (X:MessageList)        ~a out             (Y:LabelList)          = false [variant] .
  eq toKernel        (X:MessageList)        ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq toKernel        (X:MessageList)        ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq toKernel        (X:MessageList)        ~a nic-in          (Y:LabelList)          = false [variant] .
  eq toKernel        (X:MessageList)        ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq toKernel        (X:MessageList)        ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq toKernel        (X:MessageList)        ~a nextNPN         (Y:Nat)                = false [variant] .
  eq toKernel        (X:MessageList)        ~a handledCurrently(Y:Message?)           = false [variant] .
  eq toKernel        (X:MessageList)        ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq toKernel        (X:MessageList)        ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq toKernel        (X:MessageList)        ~a displayedTopBar (Y:Label)              = false [variant] .
  eq toKernel        (X:MessageList)        ~a displayedContent(Y:Label)              = false [variant] .
  eq toKernel        (X:MessageList)        ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq nextWPN         (X:Nat)                ~a rendered        (Y:Label)              = false [variant] .
  eq nextWPN         (X:Nat)                ~a URL             (Y:Label)              = false [variant] .
  eq nextWPN         (X:Nat)                ~a loading         (Y:Bool)               = false [variant] .
  eq nextWPN         (X:Nat)                ~a returnTo        (Y:ConcPipeId)         = false [variant] .
  eq nextWPN         (X:Nat)                ~a in              (Y:LabelList)          = false [variant] .
  eq nextWPN         (X:Nat)                ~a out             (Y:LabelList)          = false [variant] .
  eq nextWPN         (X:Nat)                ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq nextWPN         (X:Nat)                ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq nextWPN         (X:Nat)                ~a nic-in          (Y:LabelList)          = false [variant] .
  eq nextWPN         (X:Nat)                ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq nextWPN         (X:Nat)                ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq nextWPN         (X:Nat)                ~a nextNPN         (Y:Nat)                = false [variant] .
  eq nextWPN         (X:Nat)                ~a handledCurrently(Y:Message?)           = false [variant] .
  eq nextWPN         (X:Nat)                ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq nextWPN         (X:Nat)                ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq nextWPN         (X:Nat)                ~a displayedTopBar (Y:Label)              = false [variant] .
  eq nextWPN         (X:Nat)                ~a displayedContent(Y:Label)              = false [variant] .
  eq nextWPN         (X:Nat)                ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq rendered        (X:Label)              ~a URL             (Y:Label)              = false [variant] .
  eq rendered        (X:Label)              ~a loading         (Y:Bool)               = false [variant] .
  eq rendered        (X:Label)              ~a returnTo        (Y:ConcPipeId)         = false [variant] .
  eq rendered        (X:Label)              ~a in              (Y:LabelList)          = false [variant] .
  eq rendered        (X:Label)              ~a out             (Y:LabelList)          = false [variant] .
  eq rendered        (X:Label)              ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq rendered        (X:Label)              ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq rendered        (X:Label)              ~a nic-in          (Y:LabelList)          = false [variant] .
  eq rendered        (X:Label)              ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq rendered        (X:Label)              ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq rendered        (X:Label)              ~a nextNPN         (Y:Nat)                = false [variant] .
  eq rendered        (X:Label)              ~a handledCurrently(Y:Message?)           = false [variant] .
  eq rendered        (X:Label)              ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq rendered        (X:Label)              ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq rendered        (X:Label)              ~a displayedTopBar (Y:Label)              = false [variant] .
  eq rendered        (X:Label)              ~a displayedContent(Y:Label)              = false [variant] .
  eq rendered        (X:Label)              ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq URL             (X:Label)              ~a loading         (Y:Bool)               = false [variant] .
  eq URL             (X:Label)              ~a returnTo        (Y:ConcPipeId)         = false [variant] .
  eq URL             (X:Label)              ~a in              (Y:LabelList)          = false [variant] .
  eq URL             (X:Label)              ~a out             (Y:LabelList)          = false [variant] .
  eq URL             (X:Label)              ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq URL             (X:Label)              ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq URL             (X:Label)              ~a nic-in          (Y:LabelList)          = false [variant] .
  eq URL             (X:Label)              ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq URL             (X:Label)              ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq URL             (X:Label)              ~a nextNPN         (Y:Nat)                = false [variant] .
  eq URL             (X:Label)              ~a handledCurrently(Y:Message?)           = false [variant] .
  eq URL             (X:Label)              ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq URL             (X:Label)              ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq URL             (X:Label)              ~a displayedTopBar (Y:Label)              = false [variant] .
  eq URL             (X:Label)              ~a displayedContent(Y:Label)              = false [variant] .
  eq URL             (X:Label)              ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq loading         (X:Bool)               ~a returnTo        (Y:ConcPipeId)         = false [variant] .
  eq loading         (X:Bool)               ~a in              (Y:LabelList)          = false [variant] .
  eq loading         (X:Bool)               ~a out             (Y:LabelList)          = false [variant] .
  eq loading         (X:Bool)               ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq loading         (X:Bool)               ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq loading         (X:Bool)               ~a nic-in          (Y:LabelList)          = false [variant] .
  eq loading         (X:Bool)               ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq loading         (X:Bool)               ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq loading         (X:Bool)               ~a nextNPN         (Y:Nat)                = false [variant] .
  eq loading         (X:Bool)               ~a handledCurrently(Y:Message?)           = false [variant] .
  eq loading         (X:Bool)               ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq loading         (X:Bool)               ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq loading         (X:Bool)               ~a displayedTopBar (Y:Label)              = false [variant] .
  eq loading         (X:Bool)               ~a displayedContent(Y:Label)              = false [variant] .
  eq loading         (X:Bool)               ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq returnTo        (X:ConcPipeId)         ~a in              (Y:LabelList)          = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a out             (Y:LabelList)          = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a nic-in          (Y:LabelList)          = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a nextNPN         (Y:Nat)                = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a handledCurrently(Y:Message?)           = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a displayedTopBar (Y:Label)              = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a displayedContent(Y:Label)              = false [variant] .
  eq returnTo        (X:ConcPipeId)         ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq in              (X:LabelList)          ~a out             (Y:LabelList)          = false [variant] .
  eq in              (X:LabelList)          ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq in              (X:LabelList)          ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq in              (X:LabelList)          ~a nic-in          (Y:LabelList)          = false [variant] .
  eq in              (X:LabelList)          ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq in              (X:LabelList)          ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq in              (X:LabelList)          ~a nextNPN         (Y:Nat)                = false [variant] .
  eq in              (X:LabelList)          ~a handledCurrently(Y:Message?)           = false [variant] .
  eq in              (X:LabelList)          ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq in              (X:LabelList)          ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq in              (X:LabelList)          ~a displayedTopBar (Y:Label)              = false [variant] .
  eq in              (X:LabelList)          ~a displayedContent(Y:Label)              = false [variant] .
  eq in              (X:LabelList)          ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq out             (X:LabelList)          ~a mem-in          (Y:MaybeLabel)         = false [variant] .
  eq out             (X:LabelList)          ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq out             (X:LabelList)          ~a nic-in          (Y:LabelList)          = false [variant] .
  eq out             (X:LabelList)          ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq out             (X:LabelList)          ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq out             (X:LabelList)          ~a nextNPN         (Y:Nat)                = false [variant] .
  eq out             (X:LabelList)          ~a handledCurrently(Y:Message?)           = false [variant] .
  eq out             (X:LabelList)          ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq out             (X:LabelList)          ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq out             (X:LabelList)          ~a displayedTopBar (Y:Label)              = false [variant] .
  eq out             (X:LabelList)          ~a displayedContent(Y:Label)              = false [variant] .
  eq out             (X:LabelList)          ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq mem-in          (X:MaybeLabel)         ~a mem-out         (Y:MaybeLabel)         = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a nic-in          (Y:LabelList)          = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a nextNPN         (Y:Nat)                = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a handledCurrently(Y:Message?)           = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a displayedTopBar (Y:Label)              = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a displayedContent(Y:Label)              = false [variant] .
  eq mem-in          (X:MaybeLabel)         ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq mem-out         (X:MaybeLabel)         ~a nic-in          (Y:LabelList)          = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a nextNPN         (Y:Nat)                = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a handledCurrently(Y:Message?)           = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a displayedTopBar (Y:Label)              = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a displayedContent(Y:Label)              = false [variant] .
  eq mem-out         (X:MaybeLabel)         ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq nic-in          (X:LabelList)          ~a nic-out         (Y:LabelSet)           = false [variant] .
  eq nic-in          (X:LabelList)          ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq nic-in          (X:LabelList)          ~a nextNPN         (Y:Nat)                = false [variant] .
  eq nic-in          (X:LabelList)          ~a handledCurrently(Y:Message?)           = false [variant] .
  eq nic-in          (X:LabelList)          ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq nic-in          (X:LabelList)          ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq nic-in          (X:LabelList)          ~a displayedTopBar (Y:Label)              = false [variant] .
  eq nic-in          (X:LabelList)          ~a displayedContent(Y:Label)              = false [variant] .
  eq nic-in          (X:LabelList)          ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq nic-out         (X:LabelSet)           ~a msgPolicy       (Y:PolicySet)          = false [variant] .
  eq nic-out         (X:LabelSet)           ~a nextNPN         (Y:Nat)                = false [variant] .
  eq nic-out         (X:LabelSet)           ~a handledCurrently(Y:Message?)           = false [variant] .
  eq nic-out         (X:LabelSet)           ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq nic-out         (X:LabelSet)           ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq nic-out         (X:LabelSet)           ~a displayedTopBar (Y:Label)              = false [variant] .
  eq nic-out         (X:LabelSet)           ~a displayedContent(Y:Label)              = false [variant] .
  eq nic-out         (X:LabelSet)           ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq msgPolicy       (X:PolicySet)          ~a nextNPN         (Y:Nat)                = false [variant] .
  eq msgPolicy       (X:PolicySet)          ~a handledCurrently(Y:Message?)           = false [variant] .
  eq msgPolicy       (X:PolicySet)          ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq msgPolicy       (X:PolicySet)          ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq msgPolicy       (X:PolicySet)          ~a displayedTopBar (Y:Label)              = false [variant] .
  eq msgPolicy       (X:PolicySet)          ~a displayedContent(Y:Label)              = false [variant] .
  eq msgPolicy       (X:PolicySet)          ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq nextNPN         (X:Nat)                ~a handledCurrently(Y:Message?)           = false [variant] .
  eq nextNPN         (X:Nat)                ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq nextNPN         (X:Nat)                ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq nextNPN         (X:Nat)                ~a displayedTopBar (Y:Label)              = false [variant] .
  eq nextNPN         (X:Nat)                ~a displayedContent(Y:Label)              = false [variant] .
  eq nextNPN         (X:Nat)                ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq handledCurrently(X:Message?)           ~a weblabels       (Y:WebProcInfoSet)     = false [variant] .
  eq handledCurrently(X:Message?)           ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq handledCurrently(X:Message?)           ~a displayedTopBar (Y:Label)              = false [variant] .
  eq handledCurrently(X:Message?)           ~a displayedContent(Y:Label)              = false [variant] .
  eq handledCurrently(X:Message?)           ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq weblabels       (X:WebProcInfoSet)     ~a netlabels       (Y:NetProcInfoSet)     = false [variant] .
  eq weblabels       (X:WebProcInfoSet)     ~a displayedTopBar (Y:Label)              = false [variant] .
  eq weblabels       (X:WebProcInfoSet)     ~a displayedContent(Y:Label)              = false [variant] .
  eq weblabels       (X:WebProcInfoSet)     ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq netlabels       (X:NetProcInfoSet)     ~a displayedTopBar (Y:Label)              = false [variant] .
  eq netlabels       (X:NetProcInfoSet)     ~a displayedContent(Y:Label)              = false [variant] .
  eq netlabels       (X:NetProcInfoSet)     ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq displayedTopBar (X:Label)              ~a displayedContent(Y:Label)              = false [variant] .
  eq displayedTopBar (X:Label)              ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  eq displayedContent(X:Label)              ~a activeWebapp    (Y:MaybeConcWebProcId) = false [variant] .

  --- 19. Add partially FVP in-attrset?(_|_) predicate for checking if an attribute of a given type exists in an attribute set
  op in-attrset?(_|_) : Attribute AttributeSet -> Bool [metadata "102 true"] .
  eq in-attrset?(fromKernel      (X:MessageList)        | (fromKernel      (Y:MessageList),        AS)) = true [variant] .
  eq in-attrset?(toKernel        (X:MessageList)        | (toKernel        (Y:MessageList),        AS)) = true [variant] .
  eq in-attrset?(nextWPN         (X:Nat)                | (nextWPN         (Y:Nat),                AS)) = true [variant] .
  eq in-attrset?(rendered        (X:MaybeLabel)         | (rendered        (Y:MaybeLabel),         AS)) = true [variant] .
  eq in-attrset?(URL             (X:Label)              | (URL             (Y:Label),              AS)) = true [variant] .
  eq in-attrset?(loading         (X:Bool)               | (loading         (Y:Bool),               AS)) = true [variant] .
  eq in-attrset?(returnTo        (X:ConcPipeId)         | (returnTo        (Y:ConcPipeId),         AS)) = true [variant] .
  eq in-attrset?(in              (X:LabelList)          | (in              (Y:LabelList),          AS)) = true [variant] .
  eq in-attrset?(out             (X:LabelList)          | (out             (Y:LabelList),          AS)) = true [variant] .
  eq in-attrset?(mem-in          (X:MaybeLabel)         | (mem-in          (Y:MaybeLabel),         AS)) = true [variant] .
  eq in-attrset?(mem-out         (X:MaybeLabel)         | (mem-out         (Y:MaybeLabel),         AS)) = true [variant] .
  eq in-attrset?(nic-in          (X:LabelList)          | (nic-in          (Y:LabelList),          AS)) = true [variant] .
  eq in-attrset?(nic-out         (X:LabelSet)           | (nic-out         (Y:LabelSet),           AS)) = true [variant] .
  eq in-attrset?(msgPolicy       (X:PolicySet)          | (msgPolicy       (Y:PolicySet),          AS)) = true [variant] .
  eq in-attrset?(nextNPN         (X:Nat)                | (nextNPN         (Y:Nat),                AS)) = true [variant] .
  eq in-attrset?(handledCurrently(X:Message?)           | (handledCurrently(Y:Message?),           AS)) = true [variant] .
  eq in-attrset?(weblabels       (X:WebProcInfoSet)     | (weblabels       (Y:WebProcInfoSet),     AS)) = true [variant] .
  eq in-attrset?(netlabels       (X:NetProcInfoSet)     | (netlabels       (Y:NetProcInfoSet),     AS)) = true [variant] .
  eq in-attrset?(displayedTopBar (X:Label)              | (displayedTopBar (Y:Label),              AS)) = true [variant] .
  eq in-attrset?(displayedContent(X:Label)              | (displayedContent(Y:Label),              AS)) = true [variant] .
  eq in-attrset?(activeWebapp    (X:MaybeConcWebProcId) | (activeWebapp    (Y:MaybeConcWebProcId), AS)) = true [variant] .
 ceq in-attrset?(A | A', AS) = in-attrset?(A | AS) if A ~a A' = false .
  eq in-attrset?(A | none)   = false .

  --- 20. Add partially FVP attr-dupl?() predicate for checking if an attribute type occurs twice in a given attribute set
  op attr-dupl? : AttributeSet -> Bool [metadata "103 true"] .
  eq attr-dupl?(fromKernel      (X:MessageList),        fromKernel      (Y:MessageList),        AS) = true [variant] .
  eq attr-dupl?(toKernel        (X:MessageList),        toKernel        (Y:MessageList),        AS) = true [variant] .
  eq attr-dupl?(nextWPN         (X:Nat),                nextWPN         (Y:Nat),                AS) = true [variant] .
  eq attr-dupl?(rendered        (X:MaybeLabel),         rendered        (Y:MaybeLabel),         AS) = true [variant] .
  eq attr-dupl?(URL             (X:Label),              URL             (Y:Label),              AS) = true [variant] .
  eq attr-dupl?(loading         (X:Bool),               loading         (Y:Bool),               AS) = true [variant] .
  eq attr-dupl?(returnTo        (X:ConcPipeId),         returnTo        (Y:ConcPipeId),         AS) = true [variant] .
  eq attr-dupl?(in              (X:LabelList),          in              (Y:LabelList),          AS) = true [variant] .
  eq attr-dupl?(out             (X:LabelList),          out             (Y:LabelList),          AS) = true [variant] .
  eq attr-dupl?(mem-in          (X:MaybeLabel),         mem-in          (Y:MaybeLabel),         AS) = true [variant] .
  eq attr-dupl?(mem-out         (X:MaybeLabel),         mem-out         (Y:MaybeLabel),         AS) = true [variant] .
  eq attr-dupl?(nic-in          (X:LabelList),          nic-in          (Y:LabelList),          AS) = true [variant] .
  eq attr-dupl?(nic-out         (X:LabelSet),           nic-out         (Y:LabelSet),           AS) = true [variant] .
  eq attr-dupl?(msgPolicy       (X:PolicySet),          msgPolicy       (Y:PolicySet),          AS) = true [variant] .
  eq attr-dupl?(nextNPN         (X:Nat),                nextNPN         (Y:Nat),                AS) = true [variant] .
  eq attr-dupl?(handledCurrently(X:Message?),           handledCurrently(Y:Message?),           AS) = true [variant] .
  eq attr-dupl?(weblabels       (X:WebProcInfoSet),     weblabels       (Y:WebProcInfoSet),     AS) = true [variant] .
  eq attr-dupl?(netlabels       (X:NetProcInfoSet),     netlabels       (Y:NetProcInfoSet),     AS) = true [variant] .
  eq attr-dupl?(displayedTopBar (X:Label),              displayedTopBar (Y:Label),              AS) = true [variant] .
  eq attr-dupl?(displayedContent(X:Label),              displayedContent(Y:Label),              AS) = true [variant] .
  eq attr-dupl?(activeWebapp    (X:MaybeConcWebProcId), activeWebapp    (Y:MaybeConcWebProcId), AS) = true [variant] .
 ceq attr-dupl?(A,AS) = attr-dupl?(AS) if in-attrset?(A | AS) = false .
  eq attr-dupl?(none) = false .
endfm

---
--- 21. Extract a Label/Pair from a Web/NetProcInfoSet by ProcessId
--- 22. Find a WebProcId in a WebProcInfoSet via NetProcId and NetProcInfoSet
--- 23. Check if a label appears in a WebProcInfo in a WebProcInfoSet
--- 24. Check if a label appears in the first component of a NetProcInfo in a NetProcInfoSet
--- 25. Check if a WebProc (specified by name or indirectly by NetProcId, NetProcInfoSet, and WebProcInfoSet)
---     has a loading?() attribute that is set to true
---
fmod IBOS-AUX-FVP is
  pr CONFIGURATION-FVP-EXT .
  pr LABEL-FVP-EXT .
  pr MSG-FVP-EXT .
  pr KERNEL-METADATA-FVP-EXT .
  pr ATTRIBUTE-FVP-EXT .

  var N M : Nat .
  var Z   : NzNat .

  var P? : ProcessId .
  var P P' : ConcProcId .
  var PP PP' : ConcPipeId .
  var MP MP' : MaybePipeId .
  var AP : AbsPipeId .
  var WP WP' : ConcWebProcId .
  var NP NP' : ConcNetProcId .
  var NN : NullProcId .
  var SP : NonPipeId .
  var UI : UIId .

  var C : Configuration .
  var NWC : NetWebProcConfig .
  var NNWC : NetWebProcNeConfig .
  var At : Attribute .
  var A A' : AttributeSet .
  var NA : NeAttributeSet .
  var WIS : WebProcInfoSet .
  var NWIS : NeWebProcInfoSet .
  var NIS : NetProcInfoSet .
  var NNIS : NeNetProcInfoSet .
  var IN IN' OUT OUT' U R L L' : Label .

  --- ABC-2. check that the display and address bar are consistent with the rendered() and URL() attributes of the active WebProc
  ---        [this is the intersection of properties P_9 and P_10 in the IBOS paper]
  op display-topbar-consistent? : ConcWebProcId Label Label Configuration -> Bool [metadata "105 true"] .
  eq display-topbar-consistent?(WP,about-blank,U,< WP |              URL(U), A > C) = true [variant] .
  eq display-topbar-consistent?(WP,R,U,          < WP | rendered(R), URL(U), A > C) = true [variant] .
 ceq display-topbar-consistent?(WP,R,U,          < P  |                      A > C) = display-topbar-consistent?(WP,R,U,C) if WP ~p P = false .
 ceq display-topbar-consistent?(WP,R,U,          < WP |                      A > C) = display-topbar-consistent?(WP,R,U,C) if                             in-attrset?(URL(about-blank)      | A) = false .
 ceq display-topbar-consistent?(WP,R,U,          < WP |                      A > C) = display-topbar-consistent?(WP,R,U,C) if R ~l about-blank = false /\ in-attrset?(rendered(about-blank) | A) = false .
  eq display-topbar-consistent?(WP,R,U,                                       none) = false .

  --- 30. Check that given Net/WebProcId is greater than all those in the Configuration
  op fresh-np-id? : ConcNetProcId Configuration -> Bool [metadata "106 false"] .
  eq fresh-np-id?(network(N    ), < network(N + M) | A  > C) = false .
  eq fresh-np-id?(network(N + Z), < network(N)     | A  > C) = fresh-np-id?(network(N + Z),C) .
  eq fresh-np-id?(NP,             none                     ) = true .
  eq fresh-np-id?(NP,             < N:NonNetPipeId | A  > C) = fresh-np-id?(NP,C) .
  eq fresh-np-id?(NP,             < SP             | A  > C) = fresh-np-id?(NP,C) .
  eq fresh-np-id?(NP,             < P              | NA > C) = fresh-np-id?(NP, < P | none > C) .
 ceq fresh-np-id?(network(N + 1),                         C) = true if fresh-np-id?(network(N),C) = true .

  op fresh-wp-id? : ConcWebProcId Configuration -> Bool [metadata "107 false"] .
  eq fresh-wp-id?(webapp(N    ), < webapp(N + M)  | A  > C) = false .
  eq fresh-wp-id?(webapp(N + Z), < webapp(N)      | A  > C) = fresh-wp-id?(webapp(N + Z),C) .
  eq fresh-wp-id?(WP,            none                     ) = true .
  eq fresh-wp-id?(WP,            < N:NonWebPipeId | A  > C) = fresh-wp-id?(WP,C) .
  eq fresh-wp-id?(WP,            < SP             | A  > C) = fresh-wp-id?(WP,C) .
  eq fresh-wp-id?(WP,            < P              | NA > C) = fresh-wp-id?(WP, < P | none > C) .
 ceq fresh-wp-id?(webapp(N + 1),                         C) = true if fresh-wp-id?(webapp(N),C) = true .

  --- 34. Check that given Net/WebProcId is greater than all those in the Net/WebProcInfoSet
  op fresh-weblabel? : ConcWebProcId WebProcInfoSet -> Bool [metadata "108 false"] .
  eq fresh-weblabel?(webapp(N),    (pi(webapp(N + M),L),wp WIS)) = false .
  eq fresh-weblabel?(webapp(N + Z),(pi(webapp(N    ),L),wp WIS)) = fresh-weblabel?(webapp(N + Z),WIS) .
  eq fresh-weblabel?(webapp(N),mtWPIS)                           = true .
 ceq fresh-weblabel?(webapp(N + Z),WIS)                          = true if fresh-weblabel?(webapp(N),WIS) = true .

  op fresh-netlabel? : ConcNetProcId NetProcInfoSet -> Bool [metadata "109 false"] .
  eq fresh-netlabel?(network(N),    (pi(network(N + M),L,L'),np NIS)) = false .
  eq fresh-netlabel?(network(N + Z),(pi(network(N    ),L,L'),np NIS)) = fresh-netlabel?(network(N + Z),NIS) .
  eq fresh-netlabel?(network(N),mtNPIS)                               = true .
 ceq fresh-netlabel?(network(N + Z),NIS)                              = true if fresh-netlabel?(network(N),NIS) = true .

  --- 21. Extract a Label/Pair from a Web/NetProcInfoSet by ProcessId
  op weblabel-by-pid : MaybeProcessId WebProcInfoSet -> MaybeLabel [metadata "110 L:Label"] .
  eq weblabel-by-pid(WP, (pi(WP,IN),wp WIS)) = IN [variant] .
 ceq weblabel-by-pid(P?, (pi(WP,IN),wp WIS)) = weblabel-by-pid(P?,WIS) if P? ~p WP = false . --- FIXME: this rule needed to solve problem in ABC proof
  eq weblabel-by-pid(P?, mtWPIS)             = nolabel .
  eq weblabel-by-pid(NP, WIS)                = nolabel .
  eq weblabel-by-pid(ui, WIS)                = nolabel .
  eq weblabel-by-pid(AP, WIS)                = nolabel .
  eq weblabel-by-pid(SP, WIS)                = nolabel .
  eq weblabel-by-pid(NN, WIS)                = nolabel .
 ceq weblabel-by-pid(WP,WIS) = nolabel if fresh-weblabel?(WP,WIS) = true .

  op netlabelpair-by-pid : MaybeProcessId NetProcInfoSet -> MaybeLabelPair [metadata "111 L:LabelPair"] .
  eq netlabelpair-by-pid(NP, (pi(NP,IN,OUT),np NIS)) = (IN,OUT) [variant] .
 ceq netlabelpair-by-pid(P?, (pi(NP,IN,OUT),np NIS)) = netlabelpair-by-pid(P?,NIS) if P? ~p NP = false .
  eq netlabelpair-by-pid(P?, mtNPIS)                 = nopair .
  eq netlabelpair-by-pid(WP, NIS)                    = nopair .
  eq netlabelpair-by-pid(ui, NIS)                    = nopair .
  eq netlabelpair-by-pid(AP, NIS)                    = nopair .
  eq netlabelpair-by-pid(SP, NIS)                    = nopair .
  eq netlabelpair-by-pid(NN, NIS)                    = nopair .
 ceq netlabelpair-by-pid(NP,NIS) = nopair if fresh-netlabel?(NP,NIS) = true .


  --- 23. Check if a label appears in a WebProcInfo in a WebProcInfoSet
  op lbl-in-weblabels? : Label WebProcInfoSet -> Bool [metadata "112 true"] .
  eq lbl-in-weblabels?(IN,(pi(WP,IN ),wp WIS)) = true [variant] .
 ceq lbl-in-weblabels?(IN,(pi(WP,IN'),wp WIS)) = lbl-in-weblabels?(IN,WIS) if IN ~l IN' = false .
  eq lbl-in-weblabels?(IN,mtWPIS)              = false .

  --- 24. Check if a label appears in the first component of a NetProcInfo in a NetProcInfoSet
  op np-by-inlbl? : Label NetProcInfoSet -> Bool [metadata "113 true"] .
  eq np-by-inlbl?(IN,pi(NP,IN, OUT),np NIS) = true [variant] .
 ceq np-by-inlbl?(IN,pi(NP,IN',OUT),np NIS) = np-by-inlbl?(IN,NIS) if IN ~l IN' = false .
  eq np-by-inlbl?(IN,               mtNPIS) = false .

  op webproc-req-attrs : AttributeSet -> Bool [metadata "114 true"] .
  eq webproc-req-attrs(toKernel(T:MessageList), fromKernel(F:MessageList), URL(U:Label), rendered(R:Label), loading(B:Bool), A) = true [variant] .
 ceq webproc-req-attrs(A) = false if in-attrset?(toKernel(mt)          | A) = false .
 ceq webproc-req-attrs(A) = false if in-attrset?(fromKernel(mt)        | A) = false .
 ceq webproc-req-attrs(A) = false if in-attrset?(URL(about-blank)      | A) = false .
 ceq webproc-req-attrs(A) = false if in-attrset?(rendered(about-blank) | A) = false .
 ceq webproc-req-attrs(A) = false if in-attrset?(loading(true)         | A) = false .
  eq webproc-req-attrs(toKernel(T:NeMessageList),   A) = webproc-req-attrs(toKernel(mt),          A) .
  eq webproc-req-attrs(fromKernel(F:NeMessageList), A) = webproc-req-attrs(fromKernel(mt),        A) .
  eq webproc-req-attrs(URL(U:NonBlankLabel),        A) = webproc-req-attrs(URL(about-blank),      A) .
  eq webproc-req-attrs(rendered(R:NonBlankLabel),   A) = webproc-req-attrs(rendered(about-blank), A) .
  eq webproc-req-attrs(loading(true),               A) = webproc-req-attrs(loading(false),        A) .

  op netproc-req-attrs : AttributeSet -> Bool [metadata "115 true"] .
  eq netproc-req-attrs(toKernel(T:MessageList), fromKernel(F:MessageList), returnTo(P:ConcPipeId),
                       mem-in(M1:MaybeLabel), mem-out(M2:MaybeLabel), in(L1:LabelList), out(L2:LabelList), A) = true [variant] .
 ceq netproc-req-attrs(A) = false if in-attrset?(toKernel(mt)     | A) = false .
 ceq netproc-req-attrs(A) = false if in-attrset?(fromKernel(mt)   | A) = false .
 ceq netproc-req-attrs(A) = false if in-attrset?(returnTo(ui)     | A) = false .
 ceq netproc-req-attrs(A) = false if in-attrset?(mem-in(nolabel)  | A) = false .
 ceq netproc-req-attrs(A) = false if in-attrset?(mem-out(nolabel) | A) = false .
 ceq netproc-req-attrs(A) = false if in-attrset?(in(mtLL)         | A) = false .
 ceq netproc-req-attrs(A) = false if in-attrset?(out(mtLL)        | A) = false .
  eq netproc-req-attrs(toKernel(T:NeMessageList),   A) = netproc-req-attrs(toKernel(mt),        A) .
  eq netproc-req-attrs(fromKernel(F:NeMessageList), A) = netproc-req-attrs(fromKernel(mt),      A) .
  eq netproc-req-attrs(returnTo(W:WebProcId),       A) = netproc-req-attrs(returnTo(ui),        A) .
  eq netproc-req-attrs(mem-in(L:Label),             A) = netproc-req-attrs(mem-in(nolabel),     A) .
  eq netproc-req-attrs(mem-out(L:Label),            A) = netproc-req-attrs(mem-out(nolabel),    A) .
  eq netproc-req-attrs(in(L:NeLabelList),           A) = netproc-req-attrs(in(mtLL),            A) .
  eq netproc-req-attrs(out(L:NeLabelList),          A) = netproc-req-attrs(out(mtLL),           A) .

  --- 3. Add partially FVP predicate for checking if an object with the named ID is in the configuration
  op in-conf? : ProcessId Configuration -> Bool [metadata "116 true"] .
  eq in-conf?(WP, < WP | toKernel(T:MessageList), fromKernel(F:MessageList), URL(U:Label), rendered(R:Label), loading(B:Bool), A > C) = true [variant] .
  eq in-conf?(NP, < NP | toKernel(T:MessageList), fromKernel(F:MessageList), returnTo(P:ConcPipeId),
                         mem-in(M1:MaybeLabel), mem-out(M2:MaybeLabel), in(L1:LabelList), out(L2:LabelList), A > C) = true [variant] .
  eq in-conf?(UI, < UI | A > C) = true [variant] .
  eq in-conf?(SP, < SP | A > C) = true [variant] .
  --- recursive cases
 ceq in-conf?(WP, < WP | A > C) = in-conf?(WP,C) if webproc-req-attrs(A) = false .
 ceq in-conf?(NP, < NP | A > C) = in-conf?(NP,C) if netproc-req-attrs(A) = false .
 ceq in-conf?(P,  < P' | A > C) = in-conf?(P,C) if P ~p P' = false .
  --- base cases
  eq in-conf?(AP, C)            = false .
  eq in-conf?(P?, none)         = false .
  --- lemmas
 ceq in-conf?(NP, C)            = false if fresh-np-id?(NP,C) = true .
 ceq in-conf?(WP, C)            = false if fresh-wp-id?(WP,C) = true .

  --- 4. Add partially FVP predicate for checking for duplicate object IDs in the configuration
  op conf-dupl? : Configuration -> Bool [metadata "117 true"] .
  eq conf-dupl?(< P | A  > < P | A' > C) = true .
  eq conf-dupl?(none) = false .
 ceq conf-dupl?(< P | none > C) = conf-dupl?(C) if in-conf?(P,C) = false .
  eq conf-dupl?(< P | NA > C) = conf-dupl?(< P | none > C) .

  op in-wis? : WebProcInfo WebProcInfoSet -> Bool [metadata "130 true"] .
  eq in-wis?(pi(WP,IN),pi(WP ,IN) ,wp WIS) = true [variant] .
 ceq in-wis?(pi(WP,IN),pi(WP',IN'),wp WIS) = in-wis?(pi(WP,IN),WIS) if WP ~p WP' and IN ~l IN' = false .
  eq in-wis?(pi(WP,IN),mtWPIS) = false .

  op in-nis? : NetProcInfo NetProcInfoSet -> Bool [metadata "131 true"] .
  eq in-nis?(pi(NP,IN,OUT),pi(NP ,IN ,OUT ),np NIS) = true [variant] .
 ceq in-nis?(pi(NP,IN,OUT),pi(NP',IN',OUT'),np NIS) = in-nis?(pi(NP,IN,OUT),NIS) if NP ~p NP' and IN ~l IN'  and OUT ~l OUT' = false .
  eq in-nis?(pi(NP,IN,OUT),mtNPIS) = false .

  op goodCtxt? : NetWebProcConfig WebProcInfoSet NetProcInfoSet -> Bool [metadata "132"] .
  eq goodCtxt?(NNWC,NWIS,  NNIS  ) = true [variant] .
  eq goodCtxt?(NNWC,NWIS,  mtNPIS) = true [variant] .
  eq goodCtxt?(none,mtWPIS,mtNPIS) = true [variant] .
  ---
  eq goodCtxt?(none,NWIS,  mtNPIS) = false [variant] .
  eq goodCtxt?(none,mtWPIS,NNIS  ) = false [variant] .
  eq goodCtxt?(none,NWIS,  NNIS  ) = false [variant] .
  eq goodCtxt?(NNWC,mtWPIS,NNIS  ) = false [variant] .
  eq goodCtxt?(NNWC,mtWPIS,mtNPIS) = false [variant] .
endfm

---
--- This module defines neeeded FVP predicates for specifying the same-origin policy (SOP) invariant
---
fmod IBOS-SOP-PRED-FVP is
  pr IBOS-AUX-FVP .
endfm

---
--- This module defines neeeded FVP predicates for specifying the address bar correctness (ABC) invariant
---
fmod IBOS-ABC-PRED-FVP is
  pr IBOS-AUX-FVP .
endfm

fmod IBOS-PREDS-FVP is
  pr IBOS-SOP-PRED-FVP .
  pr IBOS-ABC-PRED-FVP .
endfm

---
--- NON-FVP
---

---
--- 26. Canonicalizes attribute values so attribute types can be compared by standard equality
--- 27. Checks that each kind of attribute in an attribute set appears in a different set
---
fmod ATTRIBUTE-NONFVP-EXT is
  pr ATTRIBUTE-FVP-EXT .
endfm

---
--- 28. Lemmas for some FVP symbols
--- 29. Canonicalize all attribute values in all objects in Configuration
--- 30. Check that given Net/WebProcId is greater than all those in the Configuration
--- 31. Return true iff an attribute type is duplicated in some object in the Configuration
--- 32. Return true iff all Net/WebProcs in a Configuration have their required attributes (part of WF() predicate in paper)
--- 33. Check that there are no duplicate ProcessIds in a Web/NetProcInfoSet
--- 34. Check that given Net/WebProcId is greater than all those in the Net/WebProcInfoSet
--- 35. Check if a given Label occurs as first component in some NetProcInfo in a NetProcInfoSet
--- 36. Given a Net/WebProcId, extract the first/second component of a Net/WebProcInfo in a Net/WebProcInfoSet
--- 37. Check if a given ProcessId appears in a Net/WebProcInfo in a Net/WebProcInfoSet
--- 38. Check that all of the Net/WebProcs in a Configuration map bijectively to each Net/WebProcInfos in the given Net/WebProcInfoSets
--- 39. Check that each WebProc and URL() attribute map bijectively to each WebProcInfo in the given WebProcInfoSet
--- 40. For each NetProcInfo in the NetProcInfoSet, we require that IN and OUT labels match
--- 41. Check that all Fetch messages in a given message list have unique labels
---
fmod IBOS-AUX-NONFVP is
  pr IBOS-PREDS-FVP .
  pr KERNEL-POLICIES-NONFVP .
  pr ATTRIBUTE-NONFVP-EXT .

  var W N M : Nat .
  var Z     : NzNat .

  var C C' : Configuration .
  var NC : NeConfiguration .
  var NWC : NetWebProcConfig .

  var At At' : Attribute .
  var A A'   : AttributeSet .
  var NA     : NeAttributeSet .

  var P?     : ProcessId .
  var P P'   : ConcProcId .
  var PP PP' : PipeId    .
  var NPP    : NonPipeId .
  var NP NP' : ConcNetProcId .
  var NNP    : NonNetPipeId .
  var WP WP' : ConcWebProcId .
  var NWP    : NonWebPipeId .
  var NNWP   : NonConcNetWebProcId .
  var CNWP   : ConcNetWebProcId .

  var NIS  : NetProcInfoSet .
  var WIS  : WebProcInfoSet .
  var NWIS : NeWebProcInfoSet .
  var NNIS : NeNetProcInfoSet .

  var B : Bool .
  var RetMT : RetMsgType .
  var FetchMT : FetchMsgType .
  var MSGL MSGL2 : MessageList .
  var L L' L1 L2 IN OUT : Label .
  var LL LL' : LabelList .

  --- 31. Return true iff an attribute type is duplicated in some object in the Configuration
  op conf-attr-dupl? : Configuration -> Bool [metadata "119"] .
 ceq conf-attr-dupl?(< P | At, A > C) = conf-attr-dupl?(< P | A > C) if in-attrset?(At | A) = false .
  eq conf-attr-dupl?(< P | At    > C) = conf-attr-dupl?(          C) .
  eq conf-attr-dupl?(< P | none  > C) = conf-attr-dupl?(          C) .
 ceq conf-attr-dupl?(< P |     A > C) = true                         if attr-dupl?(A) = true .
  eq conf-attr-dupl?(none)            = false .
  eq conf-attr-dupl?(< CNWP | fromKernel      (X:NeMessageList), A > C) = conf-attr-dupl?(< CNWP | fromKernel(mt)        , A > C) .
  eq conf-attr-dupl?(< CNWP | toKernel        (X:NeMessageList), A > C) = conf-attr-dupl?(< CNWP | toKernel(mt)          , A > C) .
  eq conf-attr-dupl?(< CNWP | rendered        (X:NonBlankLabel), A > C) = conf-attr-dupl?(< CNWP | rendered(about-blank) , A > C) .
  eq conf-attr-dupl?(< CNWP | URL             (X:NonBlankLabel), A > C) = conf-attr-dupl?(< CNWP | URL(about-blank)      , A > C) .
  eq conf-attr-dupl?(< CNWP | loading         (true)           , A > C) = conf-attr-dupl?(< CNWP | loading(false)        , A > C) .
  eq conf-attr-dupl?(< CNWP | returnTo        (X:WebProcId)    , A > C) = conf-attr-dupl?(< CNWP | returnTo(ui)          , A > C) .
  eq conf-attr-dupl?(< CNWP | in              (X:NeLabelList)  , A > C) = conf-attr-dupl?(< CNWP | in(mtLL)              , A > C) .
  eq conf-attr-dupl?(< CNWP | out             (X:NeLabelList)  , A > C) = conf-attr-dupl?(< CNWP | out(mtLL)             , A > C) .
  eq conf-attr-dupl?(< CNWP | mem-in          (X:Label)        , A > C) = conf-attr-dupl?(< CNWP | mem-in(nolabel)       , A > C) .
  eq conf-attr-dupl?(< CNWP | mem-out         (X:Label)        , A > C) = conf-attr-dupl?(< CNWP | mem-out(nolabel)      , A > C) .

  --- 32. Return true iff all Net/WebProcs in a Configuration have their required attributes (part of WF() predicate in paper)
  op nwp-reqattrs? : NetWebProcConfig -> Bool [metadata "120"] .
 ceq nwp-reqattrs?(< NP | A > NWC) = nwp-reqattrs?(NWC) if netproc-req-attrs(A) = true  .
 ceq nwp-reqattrs?(< WP | A > NWC) = nwp-reqattrs?(NWC) if webproc-req-attrs(A) = true  .
 ceq nwp-reqattrs?(< NP | A > NWC) = false              if netproc-req-attrs(A) = false .
 ceq nwp-reqattrs?(< WP | A > NWC) = false              if webproc-req-attrs(A) = false .
  eq nwp-reqattrs?(none) = true .
  eq nwp-reqattrs?(< CNWP | fromKernel      (X:NeMessageList), A > NWC) = nwp-reqattrs?(< CNWP | fromKernel(mt)        , A > NWC) .
  eq nwp-reqattrs?(< CNWP | toKernel        (X:NeMessageList), A > NWC) = nwp-reqattrs?(< CNWP | toKernel(mt)          , A > NWC) .
  eq nwp-reqattrs?(< CNWP | rendered        (X:NonBlankLabel), A > NWC) = nwp-reqattrs?(< CNWP | rendered(about-blank) , A > NWC) .
  eq nwp-reqattrs?(< CNWP | URL             (X:NonBlankLabel), A > NWC) = nwp-reqattrs?(< CNWP | URL(about-blank)      , A > NWC) .
  eq nwp-reqattrs?(< CNWP | loading         (true)           , A > NWC) = nwp-reqattrs?(< CNWP | loading(false)        , A > NWC) .
  eq nwp-reqattrs?(< CNWP | returnTo        (X:WebProcId)    , A > NWC) = nwp-reqattrs?(< CNWP | returnTo(ui)          , A > NWC) .
  eq nwp-reqattrs?(< CNWP | in              (X:NeLabelList)  , A > NWC) = nwp-reqattrs?(< CNWP | in(mtLL)              , A > NWC) .
  eq nwp-reqattrs?(< CNWP | out             (X:NeLabelList)  , A > NWC) = nwp-reqattrs?(< CNWP | out(mtLL)             , A > NWC) .
  eq nwp-reqattrs?(< CNWP | mem-in          (X:Label)        , A > NWC) = nwp-reqattrs?(< CNWP | mem-in(nolabel)       , A > NWC) .
  eq nwp-reqattrs?(< CNWP | mem-out         (X:Label)        , A > NWC) = nwp-reqattrs?(< CNWP | mem-out(nolabel)      , A > NWC) .

  --- TODO: is there a reason for this formulation?
  --- 37. Check if a given ProcessId appears in a Net/WebProcInfo in a Net/WebProcInfoSet
  op pid-in-netlabels? : ProcessId NetProcInfoSet -> Bool [metadata "121"] .
 ceq pid-in-netlabels?(P?,NIS) = true  if (netlabelpair-by-pid(P?,NIS) ~lp nopair) = false .
 ceq pid-in-netlabels?(P?,NIS) = false if (netlabelpair-by-pid(P?,NIS) ~lp nopair) = true  .

  op pid-in-weblabels? : ProcessId WebProcInfoSet -> Bool [metadata "122"] .
 ceq pid-in-weblabels?(P?,WIS) = true  if (weblabel-by-pid(P?,WIS) ~l nolabel) = false .
 ceq pid-in-weblabels?(P?,WIS) = false if (weblabel-by-pid(P?,WIS) ~l nolabel) = true  .

  op out-netlabel-by-pid : ProcessId NetProcInfoSet -> MaybeLabel [metadata "125"] .
  eq out-netlabel-by-pid(P?,NIS) = outlbl(netlabelpair-by-pid(P?,NIS)) .

  --- 33. Check that there are no duplicate ProcessIds in a Web/NetProcInfoSet
  op weblabels-dupl? : WebProcInfoSet -> Bool [metadata "126"] .
  eq weblabels-dupl?(pi(WP,L) ,wp pi(WP,L') ,wp WIS) = true .
 ceq weblabels-dupl?(pi(WP,L)               ,wp WIS) = weblabels-dupl?(WIS) if pid-in-weblabels?(WP,WIS) = false .
  eq weblabels-dupl?(pi(WP,L))                       = false .
  eq weblabels-dupl?(mtWPIS)                         = false .

  op netlabels-dupl? : NetProcInfoSet -> Bool [metadata "127"] .
  eq netlabels-dupl?(pi(NP,L,L') ,np pi(NP,L1,L2) ,np NIS) = true .
 ceq netlabels-dupl?(pi(NP,L,L') ,np                  NIS) = netlabels-dupl?(NIS) if pid-in-netlabels?(NP,NIS) = false .
  eq netlabels-dupl?(pi(NP,L,L'))                          = false .
  eq netlabels-dupl?(mtNPIS)                               = false .

  --- 41. Check that all Fetch messages in a given message list have unique labels
  op ui-consistent? : MessageList WebProcInfoSet -> Bool [metadata "200"] .
  --- SWITCH-TAB
 ceq ui-consistent?(MSGL @ msg(PP,PP',MSG-SWITCH-TAB,OUT) @ MSGL2,WIS) = ui-consistent?(MSGL @ MSGL2,WIS) if pid-in-weblabels?(PP',WIS) = true .
 ceq ui-consistent?(MSGL @ msg(PP,PP',MSG-SWITCH-TAB,OUT) @ MSGL2,WIS) = false                            if pid-in-weblabels?(PP',WIS) = false .
  --- NEW-URL
 ceq ui-consistent?(MSGL @ msg(PP,webapp,MSG-NEW-URL,OUT) @ MSGL2,WIS) = ui-consistent?(MSGL @ MSGL2,WIS) if newurl-nodupl?(OUT,MSGL @ MSGL2) = true .
 ceq ui-consistent?(MSGL @ msg(PP,PP',MSG-NEW-URL,OUT) @ MSGL2,WIS) = false                               if PP' ~p webapp and newurl-nodupl?(OUT,MSGL @ MSGL2) = false .
  --- OTHER MESSAGES
  eq ui-consistent?(MSGL @ msg(PP,PP',RetMT,  OUT) @ MSGL2,WIS) = false .
  eq ui-consistent?(MSGL @ msg(PP,PP',FetchMT,OUT) @ MSGL2,WIS) = false .
  eq ui-consistent?(mt,WIS) = true .
  --- Simplification of WIS
 ceq ui-consistent?(MSGL,pi(WP,IN),wp WIS) = ui-consistent?(MSGL,WIS) if fresh-weblabel?(WP,WIS) = true .

  op allEqLabel? : Label LabelList -> Bool [metadata "201"] .
  eq allEqLabel?(L,LL ; L  ; LL') = allEqLabel?(L,LL ; LL') .
 ceq allEqLabel?(L,LL ; L' ; LL') = false if L ~l L' = false .
  eq allEqLabel?(L,mtLL)          = true .
endfm

---
--- This module defines needed Non-FVP predicates for specifying the same-origin (SOP) invariant
--- SOP-1. Check the same-origin policy (SOP), written `p` for brevity
---
fmod IBOS-SOP-PRED is
  pr IBOS-AUX-NONFVP .

  var B : Bool .
  var NWC : NetWebProcConfig .
  var NNWC : NetWebProcNeConfig .
  var C : Configuration .
  var A A' : AttributeSet .
  var WIS : WebProcInfoSet .
  var NWIS : NeWebProcInfoSet .
  var NIS : NetProcInfoSet .
  var NNIS : NeNetProcInfoSet .
  var ML ML2 : MessageList .
  var NI : ConcNetProcId .
  var MNI : MaybeConcNetProcId .
  var WI WI' : ConcWebProcId .
  var PI PI' : PipeId .
  var L L' IN OUT : Label .
  var LL LL' : LabelList .
  var M?  : Message? .
  var WTK WFK NTK NFK : MessageList .
  var IL OL : LabelList .
  var MI MO : MaybeLabel .

  ---(
  < N'     | fromKernel(msg(N, N', MSG-FETCH-URL, L1), ML),              A  >
  < kernel | weblabels(pi(N,L1'), WIS), netlabels(pi(N', L2', L2), NIS), A' >

  such that L1 =/= L2 or L1' =/= L2'

  < N      | in(L1, LL),                   A  >
  < kernel | netlabels(pi(N, L, L2), NIS), A' >

  such that L1 =/= L2

  < N      | out(L1),                       A  >
  < kernel | netlabels(pi(N, L', L2), NIS), A' >

  such that L1 =/= L2

  < N      | loading(true), fromKernel(msg(N', N, MSG-RETURN-URL, L2), ML), A  >
  < kernel | weblabels(pi(N, L'), WIS), netlabels(pi(N', L', L1), NIS),     A' >

  such that L1 =/= L2
  ---)

  op dropCurrHandled? : Message? -> Bool [metadata "208"] .
  eq dropCurrHandled?(NRFM:NonRetFetchMsg) = true .
  eq dropCurrHandled?(F:FetchMsg) = false .
  eq dropCurrHandled?(R:RetMsg) = false .

  op consumeCurrHandled? : ConcWebProcId ConcNetProcId Message? -> Message? [metadata "207"] .
 ceq consumeCurrHandled?(WI,NI,msg(PI,PI',MSG-FETCH-URL, L)) = none if WI ~p PI or NI ~p PI or WI ~p PI' or NI ~p PI' = true .
 ceq consumeCurrHandled?(WI,NI,msg(PI,PI',MSG-RETURN-URL,L)) = none if WI ~p PI or NI ~p PI or WI ~p PI' or NI ~p PI' = true .
 ceq consumeCurrHandled?(WI,NI,msg(PI,PI',MSG-FETCH-URL, L)) = msg(PI,PI',MSG-FETCH-URL, L) if WI ~p PI or NI ~p PI or WI ~p PI' or NI ~p PI' = false .
 ceq consumeCurrHandled?(WI,NI,msg(PI,PI',MSG-RETURN-URL,L)) = msg(PI,PI',MSG-RETURN-URL,L) if WI ~p PI or NI ~p PI or WI ~p PI' or NI ~p PI' = false .
  eq consumeCurrHandled?(WI,NI,msg(PI,PI',MSG-SWITCH-TAB,L)) = msg(PI,PI',MSG-SWITCH-TAB,L) .
  eq consumeCurrHandled?(WI,NI,msg(PI,PI',MSG-NEW-URL,   L)) = msg(PI,PI',MSG-NEW-URL,   L) .
  eq consumeCurrHandled?(WI,NI,none)                         = none .

  --- NOTE: when this is processed, the NetProc has already been created
  op currHandled1? : ConcWebProcId ConcNetProcId Label Message? -> Bool [metadata "202"] .
  --- main cases
  eq currHandled1?(WI,NI,L,msg(PI,PI',MSG-FETCH-URL, L')) = (WI ~p PI and NI ~p PI' and L ~l L') or not (WI ~p PI or NI ~p PI' or L ~l L') .
  eq currHandled1?(WI,NI,L,msg(PI,PI',MSG-RETURN-URL,L')) = (NI ~p PI and WI ~p PI' and L ~l L') or not (NI ~p PI or WI ~p PI' or L ~l L') .
  --- don't care true cases
  eq currHandled1?(WI,NI,L,msg(PI,PI',MSG-SWITCH-TAB,L')) = true .
  eq currHandled1?(WI,NI,L,msg(PI,PI',MSG-NEW-URL,   L')) = true .
  eq currHandled1?(WI,NI,L,none                         ) = true .

  op currHandled2? : Message? WebProcInfoSet -> Bool [metadata "203"] .
  --- SWITCH-TAB
 ceq currHandled2?(msg(PI,WI,MSG-SWITCH-TAB,L),WIS) = true  if PI ~p ui and pid-in-weblabels?(WI,WIS) = true  .
 ceq currHandled2?(msg(PI,WI,MSG-SWITCH-TAB,L),WIS) = false if PI ~p ui and pid-in-weblabels?(WI,WIS) = false .
  eq currHandled2?(msg(PI,NI,MSG-SWITCH-TAB,L),WIS) = false .
  eq currHandled2?(msg(PI,ui,MSG-SWITCH-TAB,L),WIS) = false .
  --- NEW-URL
 ceq currHandled2?(msg(PI,PI',MSG-NEW-URL,L), WIS) = true if PI ~p ui and PI' ~p webapp and not lbl-in-weblabels?(L,WIS) = true  .
 ceq currHandled2?(msg(PI,PI',MSG-NEW-URL,L), WIS) = true if PI ~p ui and PI' ~p webapp and not lbl-in-weblabels?(L,WIS) = false .
  --- don't care true cases
  eq currHandled2?(FM:FetchMsg,WIS) = true .
  eq currHandled2?(RM:RetMsg,WIS)   = true .
  eq currHandled2?(none,WIS)        = true .

  --- NOTE: not np-by-inlbl?() condition forces only fetch-url to be processed
  op fetchMsg1? : ConcWebProcId Bool Label MessageList NetProcInfoSet -> Bool [metadata "204"] .
 ceq fetchMsg1?(WI,B,L,ML @ msg(PI,PI',MSG-FETCH-URL,L') @ ML2,NIS) = fetchMsg1?(WI,false,L,ML @ ML2,NIS) if B and WI ~p PI and network ~p PI' and L ~l L' and not np-by-inlbl?(L,NIS) = true  .
 ceq fetchMsg1?(WI,B,L,ML @ msg(PI,PI',MSG-FETCH-URL,L') @ ML2,NIS) = false                               if B and WI ~p PI and network ~p PI' and L ~l L' and not np-by-inlbl?(L,NIS) = false .
  eq fetchMsg1?(WI,B,L,ML @ NFM:NonFetchMsg @ ML2,NIS)              = fetchMsg1?(WI,B,L,ML @ ML2,NIS) .
  eq fetchMsg1?(WI,B,L,mt,NIS)                                      = true .

  op fetchMsg2? : ConcWebProcId ConcNetProcId Label MessageList -> Bool [metadata "205"] .
 ceq fetchMsg2?(WI,NI,L,ML @ msg(PI,PI',MSG-FETCH-URL,L') @ ML2) = fetchMsg2?(WI,NI,L,ML @ ML2) if WI ~p PI and NI ~p PI' and L ~l L' = true  .
 ceq fetchMsg2?(WI,NI,L,ML @ msg(PI,PI',MSG-FETCH-URL,L') @ ML2) = false                        if WI ~p PI and NI ~p PI' and L ~l L' = false .
  eq fetchMsg2?(WI,NI,L,ML @ NFM:NonFetchMsg @ ML2)              = fetchMsg2?(WI,NI,L,ML @ ML2) .
  eq fetchMsg2?(WI,NI,L,mt)                                      = true .

  op retMsg? : ConcWebProcId ConcNetProcId Label MessageList -> Bool [metadata "206"] .
 ceq retMsg?(WI,NI,L,ML @ msg(PI,PI',MSG-RETURN-URL,L') @ ML2) = retMsg?(WI,NI,L,ML @ ML2) if NI ~p PI and WI ~p PI' and L ~l L' = true  .
 ceq retMsg?(WI,NI,L,ML @ msg(PI,PI',MSG-RETURN-URL,L') @ ML2) = false                     if NI ~p PI and WI ~p PI' and L ~l L' = false .
  eq retMsg?(WI,NI,L,ML @ NRM:NonRetMsg @ ML2)                 = retMsg?(WI,NI,L,ML @ ML2) .
  eq retMsg?(WI,NI,L,mt)                                       = true .

  --- Check the same-origin policy (SOP), written `p` for brevity
  op p : NetWebProcConfig WebProcInfoSet NetProcInfoSet Message? -> Bool? [metadata "250"] .
  --- Throw out all cases where configuration process groups/metadata inconsistent
 ceq p(< WI |                     A > NWC,WIS,NIS,M?) = false if weblabel-by-pid(WI,WIS)       = nolabel .
 ceq p(< WI | URL(L),             A > NWC,WIS,NIS,M?) = false if in-wis?(pi(WI,L),WIS)         = false   .
 ceq p(< WI | loading(B), URL(L), A > NWC,WIS,NIS,M?) = false if np-by-inlbl?(L,NIS) and not B = true    .
 ceq p(< NI |                     A > NWC,WIS,NIS,M?) = false if netlabelpair-by-pid(NI,NIS)   = nopair  .
 ceq p(< NI | returnTo(WI),       A > NWC,WIS,NIS,M?) = false if weblabel-by-pid(WI,WIS)       = nolabel .
 ceq p(< NI | returnTo(WI),       A > NWC,WIS,NIS,M?) = false if in-conf?(WI,NWC)              = false   .

 ceq p(< WI | URL(L),             A > NWC,pi(WI ,L'),wp WIS,NIS,M?) = false if L  ~l L'  = false .
 ceq p(< WI | URL(L),             A > NWC,pi(WI',L ),wp WIS,NIS,M?) = false if WI ~p WI' = false .

 ceq p(NWC,pi(WI,IN),wp WIS,                 NIS,M?) = false if in-conf?(WI,NWC)          = false .
 ceq p(NWC,             WIS,pi(NI,IN,OUT),np NIS,M?) = false if in-conf?(NI,NWC)          = false .
 ceq p(NWC,             WIS,pi(NI,IN,OUT),np NIS,M?) = false if lbl-in-weblabels?(IN,WIS) = false .
 ceq p(NWC,             WIS,pi(NI,IN,OUT),np NIS,M?) = false if IN ~l OUT                 = false .

  eq p(none,NWIS,  NIS,   M?) = false .
  eq p(none,WIS,   NNIS,  M?) = false .
  eq p(NWC, mtWPIS,NNIS,  M?) = false .
  eq p(NNWC,mtWPIS,mtNPIS,M?) = false .

  --- Whenever metadata is consistent, consume whole processing units
  --- Group 2 - loaded WebProc and NetProc
 ceq p(< WI | URL(L), loading(B), toKernel(WTK), fromKernel(WFK), A >
       < NI | returnTo(WI), fromKernel(NFK), out(OL), mem-out(MO), mem-in(MI), in(IL), toKernel(NTK), A' > NWC,
              pi(WI,L),wp WIS,pi(NI,L,L),np NIS,M?)
   = p(NWC,WIS,NIS,consumeCurrHandled?(WI,NI,M?))
  if B and currHandled1?(WI,NI,L,M?) and fetchMsg1?(WI,B,L,WTK,NIS) and fetchMsg2?(WI,NI,L,WFK)
       and allEqLabel?(L,OL ; IL) and L ~l MO and L ~l MI and retMsg?(WI,NI,L,NTK @ WFK) = true .

 ceq p(< WI | URL(L), loading(B), toKernel(WTK), fromKernel(WFK), A >
       < NI | returnTo(WI), fromKernel(NFK), out(OL), mem-out(MO), mem-in(MI), in(IL), toKernel(NTK), A' > NWC,
              pi(WI,L),wp WIS,pi(NI,L,L),np NIS,M?)
   = false
  if B and currHandled1?(WI,NI,L,M?) and fetchMsg1?(WI,B,L,WTK,NIS) and fetchMsg2?(WI,NI,L,WFK)
       and allEqLabel?(L,OL ; IL) and L ~l MO and L ~l MI and retMsg?(WI,NI,L,NTK @ WFK) = false .

  --- Group 1 - not loaded WebProc
 ceq p(< WI | loading(B), URL(L), toKernel(WTK), fromKernel(WFK), A > NWC,pi(WI,L),wp WIS,NIS,M?) = p(NWC,WIS,NIS,M?)
  if np-by-inlbl?(L,NIS) = false
  /\ fetchMsg1?(WI,B,L,WTK,NIS) and noRetMsg?(WFK) = true .

 ceq p(< WI | loading(B), URL(L), toKernel(WTK), fromKernel(WFK), A > NWC,pi(WI,L),wp WIS,NIS,M?) = false
  if np-by-inlbl?(L,NIS) = false
  /\ fetchMsg1?(WI,B,L,WTK,NIS) and noRetMsg?(WFK) = false .

 ceq p(NWC,WIS,NIS,M?) = p(NWC,WIS,NIS,none) if dropCurrHandled?(M?) = true .

  eq p(none,mtWPIS,mtNPIS,M?) = true .
endfm

---
--- This module defines neeeded Non-FVP predicates for specifying the address bar correctness (ABC) invariant
--- ABC-3. For each WebProc, the rendered() attribute should be blank or equal to the URL() attribute
---
fmod IBOS-ABC-PRED is
  pr IBOS-AUX-NONFVP .

  var NIS : NetProcInfoSet .
  var NWC : NetWebProcConfig .
  var WI : ConcWebProcId .
  var NI : ConcNetProcId .
  var A : AttributeSet .
  var ML : MessageList .
  var IN OUT L : Label .
  var B : Bool .

  --- ABC-3. For each WebProc, the rendered() attribute should be blank or equal to the URL() attribute
  --- COMPLETENESS requires attr-subset condition to negate URL/rendered pair being present
  op render-consistent? : NetWebProcConfig -> Bool [metadata "197"] .
  eq render-consistent?(< NI | A >                        NWC) = render-consistent?(NWC) .
 ceq render-consistent?(< WI | URL(OUT), rendered(L), A > NWC) = render-consistent?(NWC) if L blank-or-equal OUT = true .
 ceq render-consistent?(< WI | URL(OUT), rendered(L), A > NWC) = false                   if L blank-or-equal OUT = false .
 ceq render-consistent?(< WI | A                        > NWC) = false                   if in-attrset?(rendered(about-blank) | A) = false .
 ceq render-consistent?(< WI | A                        > NWC) = false                   if in-attrset?(URL(about-blank)      | A) = false .
  eq render-consistent?(none) = true .
  ---
  eq render-consistent?(< WI | loading(B),     A > NWC) = render-consistent?(< WI | A > NWC) .
  eq render-consistent?(< WI | toKernel(ML),   A > NWC) = render-consistent?(< WI | A > NWC) .
  eq render-consistent?(< WI | fromKernel(ML), A > NWC) = render-consistent?(< WI | A > NWC) .
endfm

--- This module gathers all additional predicates together
fmod IBOS-PREDS is
  pr IBOS-SOP-PRED .
  pr IBOS-ABC-PRED .
endfm

--- This module enriches the IBOS system extended with the `stop` rule with all additional predicates
mod IBOS-STOP-WITH-PREDS is
  pr IBOS-PREDS .
  pr IBOS-STOP .
endm
