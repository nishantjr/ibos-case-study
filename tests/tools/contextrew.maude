load ../../rltool-lib.maude
load ../../theories/numbers.maude

set include BOOL off .

fmod ACRPO-FVP-BOOL is
  sort Bool .
  op true  : -> Bool [ctor metadata "8"] .
  op false : -> Bool [ctor metadata "9"] .
endfm

fmod ACRPO-FVP-NAT is
  sorts Nat NzNat .
  subsort NzNat < Nat .
  op 0   :           ->   Nat [ctor metadata "0"] .
  op 1   :           -> NzNat [ctor metadata "1"] .
  op _+_ : Nat   Nat ->   Nat [ctor assoc comm metadata "10"] .
  op _+_ : Nat NzNat -> NzNat [ctor assoc comm metadata "10"] .
endfm

fmod ACRPO-FVP-NAT-LIST is
  pr ACRPO-FVP-NAT .
  sort NeNatList NatList .
  subsort Nat < NeNatList < NatList .
  op nil : -> NatList [ctor metadata "2"] .
  op __  : NeNatList NeNatList -> NeNatList [ctor assoc metadata "11"] .
endfm

fmod EX1 is
  pr ACRPO-FVP-BOOL .
  pr ACRPO-FVP-NAT-LIST .
  var N : Nat .
  var L : NeNatList .

  op sorted : NatList -> Bool [metadata "12"] .
  op first : NeNatList -> Nat [metadata "13"] .

  eq first(N) = N .
 ceq first(N L) = N if sorted(N L) = true .
endfm

fmod ACRPO-FVP-NAT-ID is
  sorts Nat NzNat .
  subsort NzNat < Nat .
  op 0   :           ->   Nat [ctor metadata "0"] .
  op 1   :           -> NzNat [ctor metadata "10"] .
  op _+_ : Nat   Nat ->   Nat [ctor assoc comm id: 0 metadata "11"] .
  op _+_ : Nat NzNat -> NzNat [ctor ditto metadata "11"] .
endfm

fmod ACRPO-FVP-NAT-LIST&SET-ID is
  pr ACRPO-FVP-NAT-ID .
  sort NeNatList NatList .
  subsort Nat < NeNatList < NatList .
  sort NeNatSet NatSet .
  subsort Nat < NeNatSet < NatSet .
  op nil : -> NatList [ctor metadata "1"] .
  op __  : NatList   NatList -> NatList   [ctor assoc id: nil metadata "12"] .
  op __  : NeNatList NatList -> NeNatList [ctor ditto metadata "12"] .
  op __  : NatList NeNatList -> NeNatList [ctor ditto metadata "12"] .
  op mt  : -> NatSet [ctor metadata "2"] .
  op _,_ : NatSet NatSet   -> NatSet   [ctor assoc comm id: mt metadata "13"] .
  op _,_ : NeNatSet NatSet -> NeNatSet [ctor ditto metadata "13"] .
endfm

fmod EX2 is
  pr ACRPO-FVP-BOOL .
  pr ACRPO-FVP-NAT-LIST&SET-ID .

  var N N' : Nat . var L L' : NeNatList . var S S' : NeNatSet .

  op elem : NatList -> NatSet [metadata "14"] .
  eq elem(L L') = elem(L),elem(L') .
  eq elem(N)    = N .
  eq elem(nil)  = mt .

  op add1list : NatList -> NatList [metadata "15"] .
  eq add1list(L L') = add1list(L) add1list(L') .
  eq add1list(N)    = N + 1 .
  eq add1list(nil)  = nil .

  op add1set : NatSet -> NatSet [metadata "16"] .
  eq add1set(S,S') = add1set(S), add1set(S') .
  eq add1set(N)    = N + 1 .
  eq add1set(mt)   = mt .

  --- Typing refinements needed for proof below to go through
  op elem : NeNatList -> NeNatSet [metadata "14"] .
  op add1list : NeNatList -> NeNatList [metadata "15"] .
  --- op add1set : NeNatSet -> NeNatSet [metadata "16"] .
endfm

--- # Generated by:
--- # load ../../../full-maude/full-maude-removeids.maude
--- # loop init .
--- # (remove identity attributes EX2 .)
fmod EX2-NOID is
  sorts Bool Nat NatList NatSet NeNatList NeNatSet NzNat .
  subsort Nat < NeNatList .
  subsort Nat < NeNatSet .
  subsort NeNatList < NatList .
  subsort NeNatSet < NatSet .
  subsort NzNat < Nat .
  op 0 : -> Nat
    [ctor metadata "0"] .
  op 1 : -> NzNat
    [ctor metadata "10"] .
  op _+_ : Nat Nat -> Nat
    [assoc comm ctor metadata "11 0.Nat"] .
  op _+_ : Nat NzNat -> NzNat
    [assoc comm ctor metadata "11 0.Nat"] .
  op __ : NatList NatList -> NatList
    [assoc ctor metadata "12 nil.NatList"] .
  op __ : NatList NeNatList -> NeNatList
    [assoc ctor metadata "12 nil.NatList"] .
  op __ : NeNatList NatList -> NeNatList
    [assoc ctor metadata "12 nil.NatList"] .
  op _`,_ : NatSet NatSet -> NatSet
    [assoc comm ctor metadata "13 mt.NatSet"] .
  op _`,_ : NeNatSet NatSet -> NeNatSet
    [assoc comm ctor metadata "13 mt.NatSet"] .
  op add1list : NatList -> NatList
    [metadata "15"] .
  op add1list : NeNatList -> NeNatList
    [metadata "15"] .
  op add1set : NatSet -> NatSet
    [metadata "16"] .
  op elem : NatList -> NatSet
    [metadata "14"] .
  op elem : NeNatList -> NeNatSet
    [metadata "14"] .
  op false : -> Bool
    [ctor metadata "9"] .
  op mt : -> NatSet
    [ctor metadata "2"] .
  op nil : -> NatList
    [ctor metadata "1"] .
  op true : -> Bool
    [ctor metadata "8"] .
  eq X@@@:[NatList,NatSet]+ add1list(0)
    = 1 + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ add1list(N:Nat)
    = 1 + N:Nat + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ add1list(nil)
    = nil + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ add1list(L:NeNatList L':NeNatList)
    = X@@@:[NatList,NatSet]+ add1list(L:NeNatList)add1list(L':NeNatList) .
  eq X@@@:[NatList,NatSet]+ add1set(0)
    = 1 + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ add1set(N:Nat)
    = 1 + N:Nat + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ add1set(mt)
    = mt + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ add1set(S:NeNatSet,S':NeNatSet)
    = X@@@:[NatList,NatSet]+ add1set(S:NeNatSet),add1set(S':NeNatSet) .
  eq X@@@:[NatList,NatSet]+ elem(0)
    = X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ elem(N:Nat)
    = N:Nat + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ elem(nil)
    = mt + X@@@:[NatList,NatSet] .
  eq X@@@:[NatList,NatSet]+ elem(L:NeNatList L':NeNatList)
    = X@@@:[NatList,NatSet]+ elem(L:NeNatList),elem(L':NeNatList) .
  eq mt + add1list(0)
    = 1 + mt .
  eq mt + add1list(N:Nat)
    = 1 + mt + N:Nat .
  eq mt + add1list(nil)
    = mt + nil .
  eq mt + add1list(L:NeNatList L':NeNatList)
    = mt + add1list(L:NeNatList)add1list(L':NeNatList) .
  eq mt + add1set(0)
    = 1 + mt .
  eq mt + add1set(N:Nat)
    = 1 + mt + N:Nat .
  eq mt + add1set(mt)
    = mt + mt .
  eq mt + add1set(S:NeNatSet,S':NeNatSet)
    = mt + add1set(S:NeNatSet),add1set(S':NeNatSet) .
  eq mt + elem(0)
    = mt .
  eq mt + elem(N:Nat)
    = mt + N:Nat .
  eq mt + elem(nil)
    = mt + mt .
  eq mt + elem(L:NeNatList L':NeNatList)
    = mt + elem(L:NeNatList),elem(L':NeNatList) .
  eq nil + add1list(0)
    = 1 + nil .
  eq nil + add1list(N:Nat)
    = 1 + nil + N:Nat .
  eq nil + add1list(nil)
    = nil + nil .
  eq nil + add1list(L:NeNatList L':NeNatList)
    = nil + add1list(L:NeNatList)add1list(L':NeNatList) .
  eq nil + add1set(0)
    = 1 + nil .
  eq nil + add1set(N:Nat)
    = 1 + nil + N:Nat .
  eq nil + add1set(mt)
    = mt + nil .
  eq nil + add1set(S:NeNatSet,S':NeNatSet)
    = nil + add1set(S:NeNatSet),add1set(S':NeNatSet) .
  eq nil + elem(0)
    = nil .
  eq nil + elem(N:Nat)
    = nil + N:Nat .
  eq nil + elem(nil)
    = mt + nil .
  eq nil + elem(L:NeNatList L':NeNatList)
    = nil + elem(L:NeNatList),elem(L':NeNatList) .
  eq add1list(0)
    = 1 .
  eq add1list(N:Nat)
    = 1 + N:Nat .
  eq add1list(nil)
    = nil .
  eq add1list(L:NeNatList L':NeNatList)
    = add1list(L:NeNatList)add1list(L':NeNatList) .
  eq add1set(0)
    = 1 .
  eq add1set(N:Nat)
    = 1 + N:Nat .
  eq add1set(mt)
    = mt .
  eq add1set(S:NeNatSet,S':NeNatSet)
    = add1set(S:NeNatSet),add1set(S':NeNatSet) .
  eq elem(N:Nat)
    = N:Nat .
  eq elem(nil)
    = mt .
  eq elem(L:NeNatList L':NeNatList)
    = elem(L:NeNatList),elem(L':NeNatList) .
  eq 0 + X0:[NatList,NatSet]
    = X0:[NatList,NatSet] [metadata "id" variant] .
  eq X1:[NatList,NatSet]nil
    = X1:[NatList,NatSet] [metadata "id" variant] .
  eq X1:[NatList,NatSet]nil Y1:[NatList,NatSet]
    = X1:[NatList,NatSet]Y1:[NatList,NatSet] [metadata "id" variant] .
  eq nil X1:[NatList,NatSet]
    = X1:[NatList,NatSet] [metadata "id" variant] .
  eq (X1:[NatList,NatSet]nil)Y1:[NatList,NatSet]
    = X1:[NatList,NatSet]Y1:[NatList,NatSet] [metadata "id" variant] .
  eq mt,X2:[NatList,NatSet]
    = X2:[NatList,NatSet] [metadata "id" variant] .
endfm

fmod TEST is
  pr CONTEXT-REW-SOLVER .
  pr FOFORM .
  op ex1 : -> Module [memo] .
  eq ex1 = upModule('EX1,true) .
  op ex2 : -> Module [memo] .
  eq ex2 = upModule('EX2-NOID,true) .
endfm

--- Example 1 (no id attributes, has conditional equations)
red unsortify-1(ex1) .
red unsortify(ex1,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool \/
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) .

red context-rew(ex1,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool,
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) .

red cr-simp(ex1,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool \/
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) .

red crv(ex1 ; noModule ; upModule('FOFORMSIMPLIFY-IMPL,true) ; ex1,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool \/
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) .

--- Example 2 (has id attributes, no conditional equations)
--- direct proof not possible
red reduce(ex2,true,
  'elem['add1list['L:NatList]] ?= 'add1set['elem['L:NatList]]) =/= tt .

--- inductive proof works using cover set for sort NatList:
--- {nil} {N:Nat} {L:NeNatList N:Nat}
--- base case nil
red reduce(ex2,true,
  'elem['add1list['nil.NatList]] ?= 'add1set['elem['nil.NatList]]) == tt .

--- base case Nat
red reduce(ex2,true,
  'elem['add1list['N:Nat]] ?= 'add1set['elem['N:Nat]]) == tt .

--- inductive case
red context-rew(ex2,
  'elem['add1list['L:NeNatList]] != 'add1set['elem['L:NeNatList]],
  'elem['add1list['__['L:NeNatList,'N:Nat]]] ?= 'add1set['elem['__['L:NeNatList,'N:Nat]]]
) == tt .

---------------------------------------------------------------------

mod EX1-RL is
  pr EX1 .
 crl N:Nat NL:NeNatList => N':Nat NL':NeNatList if sorted(N':Nat NL':NeNatList) = true [nonexec] .
endm

select RLTOOL .

loop rltl-init .

set print attribute on .

(select EX1-RL .)
(use tool conrew for validity on EX1 with FOFORMSIMPLIFY-IMP-IMPL .)
(declare-vars (N:Nat) U (N':Nat) U (NL:NeNatList) U (NL2:NeNatList) U (NL3:NeNatList) .)
(def-term-set (NL) | (sorted(NL)) = (true) .)
(add-goal test : (N' NL2) | true => (N NL3) | (N) = (first(N NL3)) .)
(start-proof .)
(auto .)
quit
