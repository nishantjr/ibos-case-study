load ../../rltool-lib.maude
load ../../theories/numbers.maude

set include BOOL off .

fmod ACRPO-FVP-BOOL is
  sort Bool .
  op true  : -> Bool [ctor metadata "2"] .
  op false : -> Bool [ctor metadata "3"] .
endfm

fmod ACRPO-FVP-NAT is
  sorts Nat NzNat .
  subsort NzNat < Nat .
  op 0   :           ->   Nat [ctor metadata "0"] .
  op 1   :           -> NzNat [ctor metadata "1"] .
  op _+_ : Nat   Nat ->   Nat [ctor assoc comm metadata "4"] .
  op _+_ : Nat NzNat -> NzNat [ctor assoc comm metadata "4"] .
endfm

fmod ACRPO-FVP-NAT-LIST is
  pr ACRPO-FVP-NAT .
  sort NeNatList NatList .
  subsort Nat < NeNatList < NatList .
  op __  : NeNatList NeNatList -> NeNatList [ctor assoc metadata "5"] .
  op nil : -> NatList [ctor metadata "6"] .
endfm

fmod EX1 is
  pr ACRPO-FVP-BOOL .
  pr ACRPO-FVP-NAT-LIST .
  var N : Nat .
  var L : NeNatList .

  op sorted : NatList -> Bool [metadata "7"] .
  op first : NeNatList -> Nat [metadata "8"] .

  eq first(N) = N .
 ceq first(N L) = N if sorted(N L) = true .
endfm

fmod TEST is
  pr CONTEXT-REW-SOLVER .
  pr FOFORM .
  op ex1 : -> Module [memo] .
 ceq ex1 = upModule('EX1,true) if wf-metadata(upModule('EX1,true)) .
endfm

red ex1 .

red context-rew(ex1,2,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool,
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) == mtForm .

red cr-simp(ex1,2,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool \/
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) .

red crv(ex1 ; noModule ; upModule('FOFORMSIMPLIFY-IMPL,true) ; ex1,2,
  'sorted['__['N:Nat,'L:NeNatList]] != 'true.Bool \/
  'first ['__['N:Nat,'L:NeNatList]] ?= 'N:Nat) .

---------------------------------------------------------------------

mod EX1-RL is
  pr EX1 .
 crl N:Nat NL:NeNatList => N':Nat NL':NeNatList if sorted(N':Nat NL':NeNatList) = true [nonexec] .
endm

select RLTOOL .

loop rltl-init .

set print attribute on .

(select EX1-RL .)
(use tool conrew for validity on EX1 with FOFORMSIMPLIFY-IMP-IMPL .)
(declare-vars (N:Nat) U (N':Nat) U (NL:NeNatList) U (NL2:NeNatList) U (NL3:NeNatList) .)
(def-term-set (NL) | (sorted(NL)) = (true) .)
(add-goal test : (N' NL2) | true => (N NL3) | (N) = (first(N NL3)) .)
(start-proof .)
(auto .)
quit
