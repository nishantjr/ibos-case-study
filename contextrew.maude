--- This file implements a contextual rewriting-based
--- CNF-formula validity checker which uses an order-sorted
--- congruence closure algorithm (that supports axioms) as its
--- primary workhorse. The valdity checking process goes like this:
--- through several steps:
--- [1] it checks the module supports contextual rewriting (i.e. congruence closure)
--- [2] converts the formula to CNF
--- [3] applies a variant-unifiication-based clause simplifier
---     whenever possible to generate sets of simplified clauses
---
--- At this point, we must now check EACH clause is VALID:
---
--- [4] if any clause can be solved with variant-satisfiability, that will be attempted:
---     otherwise, the variables in the clause will become constants, and then
---     the antecedent will pass to a congruence closure algorithm
--- [5] the succedent will be rewritten with the union of the congruence-closure
---     generated rewrite theory; if any of the equalities in the succedent drop
---     out, the clause is valid---otherwise, we don't know
--- [6] we either return true or a simplified CNF formula containing the conjunction
---     of all of the clauses we could not solve

--- Module provides a variant-satisfiability-based clause solver;
--- given a clause, if any atom in the succedent falls within an
--- FVP fragment which protects an OS-compact constructor subtheory,
--- we then can perform variant satisfiability to solve the clause
fmod VAR-SAT-CLAUSE-SOLVER is
  pr VAR-UNIF-CLAUSE-SIMPLIFIER . --- for filter-disj()
  pr VAR-SAT .                    --- for var-sat()
  pr GENERIC-FORMULA-REDUCTION .  --- for MaybeBool and QFFormSetBoolPair

  op vs-valid-clauses  : Module DisjSet         -> QFFormSetBoolPair .
  op vs-valid-clauses1 : Module DisjSet DisjSet -> QFFormSetBoolPair .
  op vs-valid-clauses2 : Module FOFormPair      -> MaybeBool .

  var ND : NegDisj? . var PD P1 P2 : PosDisj? . var PA : PosEqAtom . var DS : Disj .
  var U : Module . var D D' : DisjSet . var B B' : Bool .

  --- INP: Module DisjSet (Clause)
  --- PRE: Module is FVP and protects OS-compact constructor subtheory
  --- OUT: Given a set of clauses CS:
  ---      If all clauses can be proved valid by var-sat, returns (mtFormSet,true)
  ---      Otherwise, returns (CS',false) where CS' is the set of clauses that cannot be proved invalid
  --- [0] if noModule, we are done
  eq vs-valid-clauses (noModule,D)          = (D,nobool) .
  eq vs-valid-clauses (U,D)                 = vs-valid-clauses1(U,D,mtFormSet) [owise] .
  --- [1] separate positive part of clause into var-sat applicable part; throw out any valid clauses
  eq vs-valid-clauses1(U,ND \/ PD | D,D')   = if vs-valid-clauses2(U,filter-disj(U,PD,mtForm,mtForm)) == true then vs-valid-clauses1(U,D,D') else vs-valid-clauses1(U,D,D' | ND \/ PD) fi .
  eq vs-valid-clauses1(U,mtFormSet,D')      = (D',if D' == mtFormSet then true else nobool fi) .
  --- [2] check if any of the var-sat applicable conjuncts is valid
  eq vs-valid-clauses2(U,(PA \/ P1,P2))     = if var-valid(U,PA) then true else if (P1 \/ P2) == mtForm then nobool else vs-valid-clauses2(U,(P1,P2)) fi fi .
  eq vs-valid-clauses2(U,(mtForm,P2))       = nobool .
endfm

--- this module provides functions to check that a module is usuable for
--- congruence closure (and thus contextural rewriting); essentially, we
--- mean no adhoc-overloading and all subsorted-overloaded families of
--- operators are labelled with the same unique number (rep. term order)
--- NOTE: we need to allow for ad-hoc overloaded constants, so special
---       case the handling of that particular operator family
fmod CR-SAFETY is
  pr OPDECL-EXTRA . --- provides metadata() function
  pr OP-FAMILY .    --- provides getOpFamilies() and OpFamilyMap datastructure
  pr CONVERSION .   --- provides rat() function
  op wf-metadata : Module          -> Bool .
  op wf-metadata : OpFamily QidSet -> Bool .
  op wfm         : OpDeclSet       ~> Qid .

  var O O' : OpDecl   . var OS  : OpDeclSet   . var I : Qid    . var Q : QidSet .
  var TYL  : TypeList . var OFM : OpFamilyMap . var U : Module .

  --- INP: Module
  --- PRE: None
  --- OUT: true iff each subsort-overloaded opfamily is labelled by a unique number
  eq wf-metadata(U)                      = wf-metadata(getOpFamilies(U),none) .
  eq wf-metadata(((I,TYL) |-> OS) OFM,Q) = if TYL == nil or-else wfm(OS) :: Qid then wf-metadata(OFM,if TYL =/= nil then wfm(OS) else qid(OS) fi ; Q) else false fi .
  eq wf-metadata(nil,Q)                  = true .
 ceq wfm(O O' OS)                        = wfm(O OS) if metadata(O) == metadata(O') .
 ceq wfm(O)                              = qid(metadata(O)) if rat(metadata(O),10) :: Nat .
endfm

fmod EQUATIONSET-FUNCTOR-LIFT is
  pr EQUATIONSET-FUNCTOR .
  pr FOFORMSET .

  var M : Module .
  var A A' : PosEqAtom . var AS : PosEqAtomSet .
  var NTL : NeTermList . var TL : TermList .
  var O1 O2 : Qid . var ID T T' : Term .
  --- formula conversions
  op eq2as  : Module Term         -> PosEqAtomSet .
  op eq2as  : Qid Qid Term Term   -> PosEqAtomSet .
  op eq2as  : Qid TermList        -> PosEqAtomSet .
  op as2eq  : Module PosEqAtomSet -> Term         .
  op as2eq' : Module PosEqAtomSet -> TermList     .
  --- formula conversions
  eq eq2as(M,T)                 = eq2as(eqset-opid(M),eq-opid(M),eqsetid-term(M),T) .
  eq eq2as(O1,O2,ID,O1[NTL])    = eq2as(O2,NTL) .
  eq eq2as(O1,O2,ID,O2[T,T'])   = T ?= T' .
  eq eq2as(O1,O2,ID,ID)         = mtFormSet .
  eq eq2as(O2,(O2[T,T'],TL))    = T ?= T' | eq2as(O2,TL) .
  eq eq2as(O2,empty)            = mtFormSet .
  ---
  eq as2eq(M,mtFormSet)         = eqsetid-term(M) .
  eq as2eq(M,A)                 = as2eq'(M,A) .
  eq as2eq(M,A | A' | AS)       = eqset-opid(M)[as2eq'(M,A | A' | AS)] .
  eq as2eq'(M,T ?= T' | A | AS) = eq-opid(M)[T,T'],as2eq'(M,A | AS) .
  eq as2eq'(M,T ?= T')          = eq-opid(M)[T,T'] .
endfm

fmod CONG-CLOSURE-ENRICHMENT is
  pr VARIABLES-TO-CONSTANTS .

  var T T' : Term . var VS : QidSet . var N M : Nat . var I P : Qid . var STR : String . var S : Substitution .
  var U : Module . var OS OS' : OpDeclSet . var TY : Type . var TYL : TypeList .
  var AS : AttrSet . var V : Variable .

  --- OUT: Module that has been enriched with constant bindings for each variable in the variable set
  ---      plus a substitution that maps each variable into the constant it was transformed into
  ---      Needed to perform congruence closure
  --- PRE: [1] Module should have an ACRPO order on all of its operators
  ---      [2] This ordering should be compatible with the rewrite relation defined by the equational theory of Module
  ---      [3] The identity elements for any operators should be minimal in the ordering
  ---      [4] The Nat argument should be equal to the number of identity elements in the order
  op enrichModuleForCongClosure : Module Nat VariableSet -> ModuleSubstPair .
  eq enrichModuleForCongClosure(U,N,VS) = varsToConstsWithMetadata#(shiftMetadata(U,N,| VS |),N,VS) .

  op varsToConstsWithMetadata# : Module Nat QidSet -> ModuleSubstPair  .
  eq varsToConstsWithMetadata#(U,N,VS) = varsToConstsWithMetadata#(U,N,VS,qid(opPrefix(U)),none,none) .

  op varsToConstsWithMetadata# : Module Nat QidSet Qid OpDeclSet Substitution -> ModuleSubstPair  .
  eq varsToConstsWithMetadata#(U,N,V ; VS,P,OS,S) = varsToConstsWithMetadata#(U,s(N),VS,P,OS op join(P getName(V)) : nil -> getType(V) [metadata(string(s(N),10))].,S ; V <- join(P getName(V) '. getType(V))) .
  eq varsToConstsWithMetadata#(U,N,none,P,OS,S)  = (addOps(OS,U),S) .

  op shiftMetadata : Module Nat Nat -> Module  .
  eq shiftMetadata(U,N,M) = setOps(U,shiftMetadata(N,M,getOps(U),none)) .

  op shiftMetadata : Nat Nat OpDeclSet OpDeclSet -> OpDeclSet .
  eq shiftMetadata(N,M,op I : TYL -> TY [AS metadata(STR)] . OS,OS') = shiftMetadata(N,M,OS,OS' op I : TYL -> TY [AS metadata(if rat(STR,10) > N then string(rat(STR,10) + M,10) else STR fi)] .) .
  eq shiftMetadata(N,M,none,OS')                                     = OS' .
endfm

--- Module provides the actual implemnation of contextual rewriting
--- that will be used in the satisfiablity algorithm
--- NOTE: no clause simplification is performed here
fmod CONTEXT-REW is
  pr OPDECL-TYPING            . --- for overloading?() function
  pr VARIABLES-TO-CONSTANTS   . --- variable-constant conversion
  pr FOFORM-OPERATIONS        . --- for basic formula operations
  pr FOFORM-SUBSTITUTION      . --- for formula substitution
  pr FOFORMSET-CONSTS-TO-VARS . --- map constants back into variables
  pr CNF                      . --- CNF formula transformation
  pr CR-SAFETY                . --- provides wf-metadata()
  pr A\/C-CONG-CLOSURE * (op `[_`,_`] to mr, op `{_`} to res) . --- A/C congruence closure
  pr EQUATIONSET-FUNCTOR-LIFT . --- extend a theory with equations in that theory
  pr CONG-CLOSURE-ENRICHMENT  .
  pr FOFORM-OPERATIONS        . --- gets size()
  pr SORTIFY-AUX              .
  pr UNSORTIFY .
  pr SORTIFY .
  pr FOFORM .
  pr FOFORMSET .
  pr DEBUG-PRINT .

  var U U+VS US+VS : Module . var ND : NegDisj? . var D : Disj . var N Sz : Nat . var S : Substitution . var T T' : Term .
  var CC  : AxCCState . var PD : PosDisj? . var ES : EquationSet . var AC SC SC' PS : PosEqAtomSet . var PA : PosEqAtom .
  var NND : NegDisj . var NPD : PosDisj . var D? : Disj? . var F? : QFForm? . var F F1 F2 : QFForm . var QPS : QidPairSet .

  --- OUT: simplify QFForm by contextual rewriting so that solved equalities become tt
  op cr-simp  : Module Nat QFForm? -> QFForm? .
  op cr-simp' : Module Nat Disj? -> Disj? .
  op cr-simp' : Module Nat NegDisj PosDisj? ~> Disj .
  ---
  eq cr-simp (U,N,F?) = cr-simp'(U,N,toCNF(F?)) .
  eq cr-simp'(U,N,D /\ F) = cr-simp'(U,N,D) /\ cr-simp'(U,N,F) .
  eq cr-simp'(U,N,NND \/ NPD) = cr-simp'(U,size(NND \/ NPD),NND,context-rew(U,N,NND,NPD)) .
  eq cr-simp'(U,N,D?) = D? [owise] .
  eq cr-simp'(U,Sz,NND,PD) = if size(NND \/ PD) < Sz then tt else mtForm fi \/ NND \/ PD .

  --- TODO: [1] extend this with a set of id constants/id rules that is automatically extracted from op decls
  ---       [2] replace all eqs with copies narrowed by id rules
  --- INP: Module Nat NegDisj PosDisj
  --- PRE: [1] Disj are well-formed with respect to Module
  ---      [2] Module's operators are properly annotated with an AC-RPO that is compatible with the rewrite relation
  ---      [3] Module does not have operators with the id attribute
  ---      [4] Nat is greater than or equal to the id constant with the highest value
  ---      [5] all id constants have lowest value in the AC-RPO ordering
  --- OUT: PosDisj? rewritten with equations from congruence closure of equations in NegDisj modulo B
  op context-rew  : Module Nat NegDisj PosDisj ~> Disj .
  op context-rew' : Module Nat NegDisj PosDisj ~> Disj .
  op context-rew1 : Module ModuleSubstPair NegDisj PosDisj ~> Disj .
  op context-rew2 : Module Module Substitution PosEqAtomSet PosEqAtomSet ~> Disj .
  op context-rew3 : Module Module Substitution EquationSet PosEqAtomSet ~> Disj .
  op context-rew4 : Module Module Substitution PosEqAtomSet PosEqAtomSet ~> Disj .
  ---
  eq context-rew(U,N,ND,PD)         = context-rew'(toFModule(U),N,ND,PD) .
  eq context-rew'(U,N,ND,PD)        = context-rew1(U,enrichModuleForCongClosure(U,N,vars(ND)),ND,PD) [print "PRE-CONTEXT-REW: " ND " => " PD] .
  eq context-rew1(U,(U+VS,S),ND,PD) = context-rew2(U,U+VS,S,toNegSet(unsortify(U,ND << S)),toPosSet(PD << S)) .
  eq context-rew2(U,U+VS,S,AC,SC)   = context-rew3(U,U+VS,S,doCongClosure(U+VS,getSig(unsortify(U+VS)),AC),SC) .
  eq context-rew3(U,U+VS,S,ES,SC)   = context-rew4(U,U+VS,S,SC,applyCongClosureEquations(U+VS,ES,SC)) .
  eq context-rew4(U,U+VS,S,SC,SC')  = print-disj(constsToVars(S,SC')) .

  --- Contextual Rewriting Implementation
  ---------------------------------------
  --- OUT: Perform congruence closure using the given set of disequalities as the equalities to be used
  --- PRE: [1] The Module should satisfy the requirements above
  ---      [2] The Module should be enriched by any variables in NegEqAtomSet
  op doCongClosure : Module Module NegEqAtomSet ~> EquationSet .
  eq doCongClosure(U+VS,US+VS,AC) = verifyCongClosure(U+VS,eqsetid-term(US+VS),init-ac-cc(US+VS,as2eq(US+VS,AC))) .

  --- OUT: [1] verifies congruence closure success by checking that passed in equalities were reduced
  ---      [2] returns the congruence closure generated equations with sorts added back in
  op verifyCongClosure : Module Term AxCCState ~> EquationSet .
  eq verifyCongClosure(U+VS,T,[ES,N,T ]) = sortify(ES,constsToQTS(U+VS)) .
 ceq verifyCongClosure(U+VS,T,[ES,N,T']) = none if debug-print("Congruence closure verification failed!") [owise] .

  --- TODO: create version that rewrites with ES only first, since that
  ---       version is convergent but the combination may not be
  --- OUT: return term T rewritten by module U with equations ES added
  op rewWithEqs : Module EquationSet Term -> Term .
  eq rewWithEqs(U,ES,T) = getTerm(metaReduce(addEqs(ES,eqset-func(U)),T)) .
  eq rewWithEqs(U:[Module],EK:[EquationSet],T:[Term]) = 'error [label rewWithEqs!] .

  --- OUT: rewrites given equalities by the congruence closure generated equations
  op applyCongClosureEquations : Module EquationSet PosEqAtomSet -> PosEqAtomSet .
  eq applyCongClosureEquations(U+VS,ES,SC) = eq2as(U+VS,rewWithEqs(U+VS,ES,as2eq(U+VS,SC))) .

  --- auxiliary functions
  -----------------------
  --- OUT: debugging printer
  op print-disj : PosDisj ~> PosDisj .
  eq print-disj(PD) = PD [print "RESULT: " PD] .

  --- lift unsorted/sorted conversions to modules
  op unsortify : Module QFForm? -> QFForm? .
  eq unsortify(U,mtForm)   = mtForm .
  eq unsortify(U,F1 /\ F2) = unsortify(U,F1) /\ unsortify(U,F2) .
  eq unsortify(U,F1 \/ F2) = unsortify(U,F1) \/ unsortify(U,F2) .
  eq unsortify(U,~ F1)     = ~ unsortify(U,F1) .
  eq unsortify(U,T ?= T')  = unsortify(U,T) ?= unsortify(U,T') .
  eq unsortify(U,T != T')  = unsortify(U,T) != unsortify(U,T') .

  op sortify : QFForm? QidPairSet -> QFForm? .
  eq sortify(mtForm,QPS)   = mtForm .
  eq sortify(F1 /\ F2,QPS) = sortify(F1,QPS) /\ sortify(F2,QPS) .
  eq sortify(F1 \/ F2,QPS) = sortify(F1,QPS) \/ sortify(F2,QPS) .
  eq sortify(~ F1,QPS)     = ~ sortify(F1,QPS) .
  eq sortify(T ?= T',QPS)  = sortify(T,QPS) ?= sortify(T',QPS) .
  eq sortify(T != T',QPS)  = sortify(T,QPS) != sortify(T',QPS) .

  --- INP: PosDisj/NegDisj or PosEqAtomSet
  --- PRE: Sometimes non-emptiness
  --- OUT: PosEqAtomSet or PosDisj/NegDisj
  op toNegSet : NegDisj -> PosEqAtomSet .
  eq toNegSet(T != T')       = T ?= T' .
  eq toNegSet(T != T' \/ ND) = T ?= T' | toNegSet(ND) .
  eq toNegSet(mtForm)        = mtFormSet .

  op toPosSet : PosDisj -> PosEqAtomSet .
  eq toPosSet(PA)       = PA .
  eq toPosSet(PA \/ PD) = PA | toPosSet(PD) .
  eq toPosSet(mtForm)   = mtFormSet .

  op toPosDisj : PosEqAtomSet -> PosDisj? .
  eq toPosDisj(PA | PS)   = PA \/ toPosDisj(PS) .
  eq toPosDisj(mtFormSet) = mtForm .
endfm

--- Module provides an implementation of contextual-rewriting based satisfiability
--- (which offloads to a variant-satisfiability based solver whenever possible)
fmod CONTEXT-REW-SOLVER is
  pr CNF .                        --- provides toCNF()
  pr FOFORMREDUCE .               --- provides reduce()
  pr FOFORMSET-OPERATIONS .       --- provides DisjSet data structure and conversion in DisjSet
  pr VAR-UNIF-CLAUSE-SIMPLIFIER . --- provides vu-clause-simp()
  pr FOFORM-EXTRACT-SUBSTITUTION . --- get extract sub
  pr CONTEXT-REW .                --- provides context-rew()

  op crv      : NeModuleList Nat QFForm  -> QFForm? .
  op crv'     : NeModuleList Nat QFForm? -> QFForm? .
  op crv-conj : NeModuleList Nat QFForm? -> QFForm? .
  op crv-disj : NeModuleList Nat Disj    -> QFForm? .
  op crv-run  : NeModuleList Nat Disj    -> QFForm? .

  var ML : [NeModuleList] .
  var RewMod VSMod SimpMod CRMod : Module .
  var D : Disj .
  var F : QFForm .
  var N : Nat .

  --- validity check goes as follows:
  eq crv (ML,N,F) = simplify(crv'(ML,N,F)) .
  eq crv'(ML,N,F) = crv-conj(ML,N,simplify(toCNF(F))) .
  eq crv-conj(ML,N,D /\ F) = crv-disj(ML,N,D) /\ crv-conj(ML,N,F) .
  eq crv-conj(ML,N,D) = crv-disj(ML,N,D) .
  eq crv-conj(ML,N,mtForm) = mtForm .
  eq crv-disj(ML,N,D) =
    if crv-run(ML,N,D) == D
      then D
      else crv'(ML,N,crv-run(ML,N,D))
    fi .
  eq crv-run(RewMod ; VSMod ; SimpMod ; CRMod,N,D) =
    cr-simp(CRMod,N,downTerm(modReduce(SimpMod,
      upTerm(reduce(RewMod,false,
               extract-clause-sub(RewMod,
                 vu-clause-simp(VSMod,D))))),error("crv-disj failed"))) .
endfm

fmod CONTEXT-REW-BACKEND-IMPL is
  pr RLTOOL-BACKEND .
  pr CONTEXT-REW-SOLVER .
  pr REACH-PROOF-STATE-OPS .
  pr FOFORM-CORE-PRETTYPRINT .

  var D : ProofMetadata .
  var MQL : ScopedMapList .
  var F : QFForm? .
  var M : Module .
  var ModArgs : ModuleList .

  --- TODO: propery parameterize id constant metadata argument
  eq checkVal((M,'conrew,ModArgs),MQL,D,F) =
    if ModArgs :: Module then
      --- FIXME: set output back to false when we are done
      if @ppCNF(true,'tt.Pred,
        crv(get-mod(D) ;
	    getbackend('validity,'varsat,get-reg(D)) ;
	    ModArgs ;
	    toFModule(getbackend('validity,'conrew,get-reg(D))),0,F)) == tt then true else nobool fi
      else errb('conrew 'requires 'single 'module 'argument)
    fi .
  eq checkUnsat((M,'conrew,ModArgs),MQL,D,F) = nobool .
endfm

---(
--- TODO: rethink this or remove it
--- Module provides method to check if a clause in a set of clauses is NOT valid:
--- This is applied as a last resort if we do not know how to proceed
--- Strategy is as follows: if in a clause, terms in all positive atoms are:
---   [a] constructor terms
---   [b] non-narrowable with convergent equations generated from negative atoms --- still TODO
---   [c] non-unifiable with each other
--- we conclude invalid.
--- Conditions [a] and [b] ensure terms are in normal form; condition [c] ensures they have no common instances
fmod CLAUSE-INVALIDITY-CHECKER is
  pr GENERIC-FORMULA-REDUCTION .  --- provides QFFormSetBoolPair data structure
  pr FOFORMSET                  . --- DisjSet
  pr CTOR-SIG                   . --- ctor-sig
  pr FOFORM-OPERATIONS          . --- wellFormed()
  op clause-invalid?  : Module QFFormSetBoolPair -> QFFormSetBoolPair .
  op clause-invalid?  : Module DisjSet DisjSet   -> QFFormSetBoolPair .
  op clause-invalid?  : Module Disj              -> Bool .
  op clause-invalid'? : Module PosDisj?          -> Bool .
  var U : Module . var N : NegDisj . var P : PosDisj . var P? : PosDisj? . var T T' : Term . var D D' : DisjSet . var B : Bool .

  eq clause-invalid? (U,N \/ P)       = if wellFormed(ctor-sig(U),P) then clause-invalid'?(U,P) else nobool fi .
  eq clause-invalid'?(U,T ?= T' \/ P) = metaUnify(U,T =? T,0,0) == noUnifier and-then clause-invalid'?(U,P) .
  eq clause-invalid'?(U,mtForm)       = true .

  eq clause-invalid?(U,(D,nobool))    = clause-invalid?(U,D,mtFormSet) .
  eq clause-invalid?(U,(D,B))         = (D,B) .
  eq clause-invalid?(U,N \/ P | D,D') = if clause-invalid?(U,N \/ P) then (N \/ P | D | D',false) else clause-invalid?(U,D,D' | N \/ P) fi .
  eq clause-invalid?(U,mtFormSet,D')  = (D',nobool) .
endfm
---)
