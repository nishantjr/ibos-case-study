--- This file implements a contextual rewriting-based
--- CNF-formula validity checker which uses an order-sorted
--- congruence closure algorithm (that supports axioms) as its
--- primary workhorse. The valdity checking process goes like this:
--- through several steps:
--- [1] it checks the module supports contextual rewriting (i.e. congruence closure)
--- [2] converts the formula to CNF
--- [3] applies a variant-unifiication-based clause simplifier
---     whenever possible to generate sets of simplified clauses
---
--- At this point, we must now check EACH clause is VALID:
---
--- [4] if any clause can be solved with variant-satisfiability, that will be attempted:
---     otherwise, the variables in the clause will become constants, and then
---     the antecedent will pass to a congruence closure algorithm
--- [5] the succedent will be rewritten with the union of the congruence-closure
---     generated rewrite theory; if any of the equalities in the succedent drop
---     out, the clause is valid---otherwise, we don't know
--- [6] we either return true or a simplified CNF formula containing the conjunction
---     of all of the clauses we could not solve

--- Module provides a variant-satisfiability-based clause solver;
--- given a clause, if any atom in the succedent falls within an
--- FVP fragment which protects an OS-compact constructor subtheory,
--- we then can perform variant satisfiability to solve the clause
fmod VAR-SAT-CLAUSE-SOLVER is
  pr VAR-UNIF-CLAUSE-SIMPLIFIER . --- for filter-disj()
  pr VAR-SAT .                    --- for var-sat()
  pr GENERIC-FORMULA-REDUCTION .  --- for MaybeBool and QFFormSetBoolPair

  op vs-valid-clauses  : Module DisjSet         -> QFFormSetBoolPair .
  op vs-valid-clauses1 : Module DisjSet DisjSet -> QFFormSetBoolPair .
  op vs-valid-clauses2 : Module FOFormPair      -> MaybeBool .

  var ND : NegDisj? . var PD P1 P2 : PosDisj? . var PA : PosEqAtom . var DS : Disj .
  var U : Module . var D D' : DisjSet . var B B' : Bool .

  --- INP: Module DisjSet (Clause)
  --- PRE: Module is FVP and protects OS-compact constructor subtheory
  --- OUT: Given a set of clauses CS:
  ---      If all clauses can be proved valid by var-sat, returns (mtFormSet,true)
  ---      Otherwise, returns (CS',false) where CS' is the set of clauses that cannot be proved invalid
  --- [0] if noModule, we are done
  eq vs-valid-clauses (noModule,D)          = (D,nobool) .
  eq vs-valid-clauses (U,D)                 = vs-valid-clauses1(U,D,mtFormSet) [owise] .
  --- [1] separate positive part of clause into var-sat applicable part; throw out any valid clauses
  eq vs-valid-clauses1(U,ND \/ PD | D,D')   = if vs-valid-clauses2(U,filter-disj(U,PD,mtForm,mtForm)) == true then vs-valid-clauses1(U,D,D') else vs-valid-clauses1(U,D,D' | ND \/ PD) fi .
  eq vs-valid-clauses1(U,mtFormSet,D')      = (D',if D' == mtFormSet then true else nobool fi) .
  --- [2] check if any of the var-sat applicable conjuncts is valid
  eq vs-valid-clauses2(U,(PA \/ P1,P2))     = if var-valid(U,PA) then true else if (P1 \/ P2) == mtForm then nobool else vs-valid-clauses2(U,(P1,P2)) fi fi .
  eq vs-valid-clauses2(U,(mtForm,P2))       = nobool .
endfm

--- Performs to a search to see if an unordered pair can be rewritten to a different unordered pair
--- Or if a term can be rewritten to another term using an equational module
--- Note that this search is only
fmod META-SEARCH-EXT is
  pr RULIFY-FUNCTOR .
  pr TERMSET-FM .
  var U : Module .
  var E1 E2 : Equation .
  var T1 T2 : Term .

  op pairSearch : Module Equation Equation -> Bool .
  eq pairSearch(U,E1,E2) =
    if lhs(E1) in (lhs(E2) | rhs(E2)) or-else
       rhs(E1) in (lhs(E2) | rhs(E2))
      then metaNormalForm?(rulify-func(U),toEqSetTerm(U,E1),toEqSetTerm(U,E2))
      else false
    fi .

  op metaNormalForm? : Module Term Term -> Bool .
  eq metaNormalForm?(U,T1,T2) = metaSearch(U,T1,T2,nil,'!,unbounded,0) :: ResultTriple .
endfm

--- Module provides the actual implemnation of contextual rewriting
--- that will be used in the satisfiablity algorithm
--- NOTE: no clause simplification is performed here
fmod CONTEXT-REW is
  pr FOFORM-OPERATIONS     . --- size()
  pr FOFORMSIMPLIFY        . --- simplify()
  pr FOFORMREDUCE          . --- reduce()
  pr FOFORM-CONSTS-TO-VARS . --- constsToVars()
  pr CNF                   . --- toCNF()
  pr CONG-CLOSURE-LIB      . --- congClosure()
  pr META-SEARCH-EXT       .

  var U UCC : Module . var ES : EquationSet . var E : Equation .
  var S : Substitution . var Sz : Nat .
  var ND  : NegDisj? . var PD : PosDisj? . var D? : Disj? .
  var NND : NegDisj . var NPD : PosDisj . var D : Disj .
  var F   : QFForm . var F? : QFForm? .
  var CC  : CCState .

  --- INP: Module NegDisj PosDisj
  --- PRE: [1] Disj are well-formed with respect to Module
  ---      [2] Module's operators are properly annotated with an AC-RPO that is compatible with the rewrite relation
  ---      [3] Module does not have operators with the id attribute
  ---      [4] Nat is greater than or equal to the id constant with the highest value
  ---      [5] all id constants have lowest value in the AC-RPO ordering
  --- OUT: PosDisj? rewritten with equations from congruence closure of equations in NegDisj modulo B
  op context-rew : Module NegDisj PosDisj ~> PosDisj .
  eq context-rew(U,ND,PD) = context-rew1(congClosure(U,toNNF(~ ND)),PD) .

  op context-rew1 : CCResult PosDisj ~> PosDisj .
  eq context-rew1(errCCResult(QL:QidList),PD) = error(string(QL:QidList)) .
  eq context-rew1((UCC,S,ES),PD) =
    print-disj(
      constsToVars(S,
        if size(reduce(setEqs(UCC,ES),PD << S)) < size(PD)
          then reduce(setEqs(UCC,ES),PD << S)
          else if truefalseContradict(addEqs(ES,UCC),ES)
	    then mtForm
	    else reduce(addEqs(ES,UCC),PD << S)
          fi
        fi)) .

  --- OUT: simplify QFForm by contextual rewriting so that solved equalities become tt
  op cr-simp  : Module QFForm? -> QFForm? .
  op cr-simp' : Module Disj? -> Disj? .
  op cr-simp' : Module Nat NegDisj PosDisj? ~> Disj .
  ---
  eq cr-simp (U,F?) = cr-simp'(U,toCNF(F?)) .
  eq cr-simp'(U,D /\ F) = cr-simp'(U,D) /\ cr-simp'(U,F) .
  eq cr-simp'(U,NND \/ NPD) = cr-simp'(U,size(NND \/ NPD),NND,context-rew(U,NND,NPD)) .
  eq cr-simp'(U,D?) = D? [owise] .
  eq cr-simp'(U,Sz,NND,PD) = if size(NND \/ PD) < Sz then tt else mtForm fi \/ NND \/ PD .

  --- OUT: debugging printer
  op print-disj : PosDisj ~> PosDisj .
  eq print-disj(PD) = PD [print "RESULT: " PD] .

  --- OUT: true iff true and false contradict
  op truefalseContradict : Module EquationSet -> Bool .
  eq truefalseContradict(U,E ES) =
    pairSearch(U,E,eq 'true.Bool = 'false.Bool [none].)
      or-else truefalseContradict(U,ES) .
  eq truefalseContradict(U,none) = false .
endfm

--- Module provides an implementation of contextual-rewriting based satisfiability
--- (which offloads to a variant-satisfiability based solver whenever possible)
fmod CONTEXT-REW-SOLVER is
  pr CNF .                        --- provides toCNF()
  pr FOFORMREDUCE .               --- provides reduce()
  pr FOFORMSET-OPERATIONS .       --- provides DisjSet data structure and conversion in DisjSet
  pr VAR-UNIF-CLAUSE-SIMPLIFIER . --- provides vu-clause-simp()
  pr FOFORM-EXTRACT-SUBSTITUTION . --- get extract sub
  pr CONTEXT-REW .                --- provides context-rew()

  op crv      : NeModuleList QFForm  -> QFForm? .
  op crv'     : NeModuleList QFForm? -> QFForm? .
  op crv-conj : NeModuleList QFForm? -> QFForm? .
  op crv-disj : NeModuleList Disj    -> QFForm? .
  op crv-run  : NeModuleList Disj    -> QFForm? .

  var ML : [NeModuleList] .
  var RewMod VSMod SimpMod CRMod : Module .
  var D : Disj .
  var F : QFForm .

  --- validity check goes as follows:
  eq crv (ML,F) = simplify(crv'(ML,F)) .
  eq crv'(ML,F) = crv-conj(ML,simplify(toCNF(F))) .
  eq crv-conj(ML,D /\ F) = crv-disj(ML,D) /\ crv-conj(ML,F) .
  eq crv-conj(ML,D) = crv-disj(ML,D) .
  eq crv-conj(ML,mtForm) = mtForm .
  eq crv-disj(ML,D) =
    if crv-run(ML,D) == D
      then D
      else crv'(ML,crv-run(ML,D))
    fi .
  eq crv-run(RewMod ; VSMod ; SimpMod ; CRMod,D) =
    cr-simp(CRMod,downTerm(modReduce(SimpMod,
      upTerm(reduce(RewMod,false,
               extract-clause-sub(RewMod,
                 vu-clause-simp(VSMod,D))))),error("crv-disj failed"))) .
endfm

fmod CONTEXT-REW-BACKEND-IMPL is
  pr RLTOOL-BACKEND .
  pr CONTEXT-REW-SOLVER .
  pr REACH-PROOF-STATE-OPS .
  pr FOFORM-CORE-PRETTYPRINT .

  var D : ProofMetadata .
  var MQL : ScopedMapList .
  var F : QFForm? .
  var M : Module .
  var ModArgs : ModuleList .

  --- TODO: propery parameterize id constant metadata argument
  eq checkVal((M,'conrew,ModArgs),MQL,D,F) =
    if ModArgs :: Module then
      --- FIXME: set output back to false when we are done
      if @ppCNF(true,'tt.Pred,
        crv(get-mod(D) ;
	    getbackend('validity,'varsat,get-reg(D)) ;
	    ModArgs ;
	    toFModule(getbackend('validity,'conrew,get-reg(D))),F)) == tt then true else nobool fi
      else errb('conrew 'requires 'single 'module 'argument)
    fi .
  eq checkUnsat((M,'conrew,ModArgs),MQL,D,F) = nobool .
endfm

---(
--- TODO: rethink this or remove it
--- Module provides method to check if a clause in a set of clauses is NOT valid:
--- This is applied as a last resort if we do not know how to proceed
--- Strategy is as follows: if in a clause, terms in all positive atoms are:
---   [a] constructor terms
---   [b] non-narrowable with convergent equations generated from negative atoms --- still TODO
---   [c] non-unifiable with each other
--- we conclude invalid.
--- Conditions [a] and [b] ensure terms are in normal form; condition [c] ensures they have no common instances
fmod CLAUSE-INVALIDITY-CHECKER is
  pr GENERIC-FORMULA-REDUCTION .  --- provides QFFormSetBoolPair data structure
  pr FOFORMSET                  . --- DisjSet
  pr CTOR-SIG                   . --- ctor-sig
  pr FOFORM-OPERATIONS          . --- wellFormed()
  op clause-invalid?  : Module QFFormSetBoolPair -> QFFormSetBoolPair .
  op clause-invalid?  : Module DisjSet DisjSet   -> QFFormSetBoolPair .
  op clause-invalid?  : Module Disj              -> Bool .
  op clause-invalid'? : Module PosDisj?          -> Bool .
  var U : Module . var N : NegDisj . var P : PosDisj . var P? : PosDisj? . var T T' : Term . var D D' : DisjSet . var B : Bool .

  eq clause-invalid? (U,N \/ P)       = if wellFormed(ctor-sig(U),P) then clause-invalid'?(U,P) else nobool fi .
  eq clause-invalid'?(U,T ?= T' \/ P) = metaUnify(U,T =? T,0,0) == noUnifier and-then clause-invalid'?(U,P) .
  eq clause-invalid'?(U,mtForm)       = true .

  eq clause-invalid?(U,(D,nobool))    = clause-invalid?(U,D,mtFormSet) .
  eq clause-invalid?(U,(D,B))         = (D,B) .
  eq clause-invalid?(U,N \/ P | D,D') = if clause-invalid?(U,N \/ P) then (N \/ P | D | D',false) else clause-invalid?(U,D,D' | N \/ P) fi .
  eq clause-invalid?(U,mtFormSet,D')  = (D',nobool) .
endfm
---)
