*** AorC-congruence-closure-rules.maude
*** Rewrite rule based version.  Can be good for: (i) inference system as rewrite theory (more abstract); and (ii) debugging. 


mod A\/C-CONG-CLOSURE is
  pr PROCESS .
  pr CRITICAL-PAIR .

  sort State .

  op [_,_,_,_,_,_,_,_,_] : List{IMRule} EquationSet IMRuleTable FAxiomSet List{OInfo<} Process Nat Nat Nat -> State .
  op [_,_,_] : EquationSet Nat GroundTerm -> State [ctor] .  *** final result with count of overlap cycles and test

op init : -> State .

vars T T' T'' T''' : GroundTerm .  var ES : EquationSet .  var AS : AttrSet . var FAS : FAxiomSet . var OL : List{OInfo<} .
var OI : OInfo . vars i j n m k l m0 : Nat .  vars S S' S'' S''' : SetM{Qid} .  var f : Qid . var IMRT : IMRuleTable .
var MR : MRule .  var IMR : IMRule .  var MRL : List{MRule<} . var IMRL : List{IMRule} . var RS : Results .

op rem-att : AttrSet EquationSet -> EquationSet .  *** removes equation with attributes unique to the equation

eq rem-att(AS,(eq T = T' [AS] .) ES) = ES .
eq rem-att(AS,ES) = ES [owise] .

eq init = [nil,none,init-imrtab,init-faxset,nil,rules,0,0,1] .

rl [IMRL,ES,IMRT,FAS,OL,MR MRL,m0,k,j] =>
        if simpl-mrule(ES,MR) == mt-mrule
	   then [IMRL,ES,IMRT,FAS,OL,MRL,m0,k,j] 
	   else if ax top(left(simpl-mrule(ES,MR))) in FAS == free 
	          then [IMRL ([j] simpl-mrule(ES,MR)),
	                 eq left(simpl-mrule(ES,MR)) = right(simpl-mrule(ES,MR)) [metadata(string(j,10))] . ES,
			 IMRT,FAS,OL,reduce-imrules(simpl-mrule(ES,MR),IMRL) # MRL,m0,k,s(j)]
	           else [IMRL ([j] simpl-mrule(ES,MR)),
	                 eq left(simpl-mrule(ES,MR)) = right(simpl-mrule(ES,MR)) [metadata(string(j,10))] . ES,
			 add-imrule(top(left(simpl-mrule(ES,MR))),([j] simpl-mrule(ES,MR)),IMRT),
			                     FAS,OL,reduce-imrules(simpl-mrule(ES,MR),IMRL) # MRL,m0,k,s(j)]
                fi						 
	fi .

rl [IMRL,ES,IMRT,FAS,OL,{i} RS # MRL,m0,k,j] => [IMRL,ES,IMRT,FAS,OL,RS # MRL,m0,k,j] .

rl [IMRL,ES,IMRT,FAS,OL,{f,[i] mt-mrule} RS # MRL,m0,k,j] =>
        [remove(i,IMRL),rem-att(metadata(string(i,10)),ES),remove([i,f],IMRT),FAS,OL, RS # MRL,m0,k,j] .  
	
rl [IMRL,ES,IMRT,FAS,OL,{f,[i] T [n,S] => T' [m,S']} RS # MRL,m0,k,j] =>
         [remove(i,IMRL),rem-att(metadata(string(i,10)),ES),remove([i,f],IMRT),FAS,OL,RS # ins(T [n,S] => T' [m,S'],MRL),m0,k,j] .

rl [IMRL,ES,IMRT,FAS,nil,nil,m0,k,s(j)] => if m0 == j then [ES,k,getTerm(metaReduce(fmod 'TEST-RULES is including 'U-EQ .
		                                                                          sorts none .
				  	                                                  none
                                                                                          none
				                                                	  none
				                                                   	  ES
				                                                	  endfm,'equations.Eqs))]
							else [IMRL,ES,IMRT,FAS,compute-overlaps(IMRT,m0),nil,j,s(k),s(j)]
					fi .

rl [IMRL,ES,IMRT,FAS,OI OL,nil,m0,k,j] =>  [IMRL,ES,IMRT,FAS,OL,clean(sort(make-rule-map(CPS(OI,IMRT,FAS)))),m0,k,j] .
endm

***(
result [State]:
[
([1]'__['a.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U] => 'b.U [1,'b.U])
([2]'__['a.U,'b.U,'b.U,'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'a.U] [3,'__  & 'a.U])
([3]'__['__['a.U,'a.U],'a.U] [5,'__ & 'a.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U])
([4]'__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['b.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U])
([5]'__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U]),
eq '__['__['a.U,'a.U],'a.U] = '__['a.U,'b.U] [metadata("3")] .
eq '__['__['a.U,'b.U],'a.U] = '__['a.U,'b.U] [metadata("5")] .
eq '__['__['a.U,'b.U],'__['a.U,'a.U]] = '__['b.U,'a.U,'b.U] [metadata("4")] .
eq '__['a.U,'a.U,'b.U] = 'b.U [metadata("1")] .
eq '__['a.U,'b.U,'b.U,'a.U] = '__['a.U,'a.U] [metadata("2")] .,
['_+_,empty] @
['__,[1]'__['a.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U] => 'b.U [1,'b.U],
     [2]'__['a.U,'b.U,'b.U,'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'a.U] [3,'__ & 'a.U],
     [3]'__['__['a.U,'a.U],'a.U] [5,'__ & 'a.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U],
     [4]'__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['b.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U],
     [5]'__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U]],
['_+_,AC] @ ['__,A],
[[4,'__],[4,1] & [4,2] & [4,3] & [4,4]],
{1} {2} {3} {'__,[4]make-rule('__['a.U, 'b.U], p1(failure))}
    # ('__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'__['a.U,'b.U]] [5,'__ & 'a.U & 'b.U])
      ('__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'__['a.U,'a.U]] [5,'__ & 'a.U])
      ('__['a.U,'__['a.U,'b.U]] [5,'__ & 'a.U & 'b.U] => '__['__['a.U,'a.U],'a.U] [5,'__ & 'a.U])
      ('__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['__['a.U,'a.U],'b.U] [5,'__ & 'a.U & 'b.U])
      ('__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['__['a.U,'a.U],'__['a.U,'b.U]] [7,'__ & 'a.U & 'b.U]),
4,2,6]

result State:
[
([1]'__['a.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U] => 'b.U [1,'b.U])
([2]'__['a.U,'b.U,'b.U,'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'a.U] [3,'__ & 'a.U])
([3]'__['__['a.U,'a.U],'a.U] [5,'__ & 'a.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U])
([4]'__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U]  => '__['b.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U])
([5]'__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U]),
eq '__['__['a.U,'a.U],'a.U] = '__['a.U,'b.U] [metadata("3")] .
eq '__['__['a.U,'b.U],'a.U] = '__['a.U,'b.U] [metadata("5")] .
eq '__['__['a.U,'b.U],'__['a.U,'a.U]] = '__['b.U,'a.U,'b.U] [metadata("4")] .
eq '__['a.U,'a.U,'b.U] = 'b.U [metadata("1")] .
eq '__['a.U,'b.U,'b.U,'a.U] = '__['a.U,'a.U] [metadata("2")] .,
['_+_,empty] @
['__,[1]'__['a.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U] => 'b.U [1,'b.U],
     [2]'__['a.U,'b.U,'b.U,'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'a.U] [3,'__ & 'a.U],
     [3]'__['__['a.U,'a.U],'a.U] [5,'__ & 'a.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U],
     [4]'__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['b.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U],
     [5]'__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U]],
['_+_,AC] @ ['__,A],
[[4,'__],[4,1] & [4,2] & [4,3] & [4,4]],
{'__,[4]'__['b.U,'a.U,'b.U] [4,'__ & 'a.U & 'b.U] => '__['a.U,'b.U] [3,'__ & 'a.U & 'b.U]}
    # ('__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'__['a.U,'b.U]] [5,'__ & 'a.U & 'b.U])
      ('__['__['a.U,'b.U],'a.U] [5,'__ & 'a.U & 'b.U] => '__['a.U,'__['a.U,'a.U]] [5,'__ & 'a.U])
      ('__['a.U,'__['a.U,'b.U]] [5,'__ & 'a.U & 'b.U] => '__['__['a.U,'a.U],'a.U] [5,'__ & 'a.U])
      ('__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['__['a.U,'a.U],'b.U] [5,'__ & 'a.U & 'b.U])
      ('__['__['a.U,'b.U],'__['a.U,'a.U]] [7,'__ & 'a.U & 'b.U] => '__['__['a.U,'a.U],'__['a.U,'b.U]] [7,'__ & 'a.U & 'b.U]),
4,2,6]

)
