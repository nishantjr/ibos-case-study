--- The initial state "init" starts with the sorted list of marked rules generated by the equations specified by the user with constant
--- "equations" in module U-EQ.  Furthermore, to allow the case where there can be A\/C\U axioms, the second component
--- of the initial state has initially a module with the identity axioms (U) specified as rules.
--- In the case where all symbols are free, roughly, being sorted with smaller righthand sides first
--- should ensure an O(n^2) complexity using hash-consing
--- according to Plaisted-and-Sattler-Klein, but this algorithm is more eager than theirs, since rules are fully reduced by
--- previous ones before being added to a set of inter-reduced rules.  The invariant kept by the algorithm is that the rules
--- in the 1st and 2nd components are always inter-reduced; therefore in the free+U case they are convergent (locally confluent, since no CPs exist, and
--- terminating by construction).  This means that when no more equations remain in the third component we have reached the
--- desired congruence closure.  The third component is a version of the rules in the first component as a set of equations, to avoid
--- recomputing that set for simplification purposes.  Another invariant is that the rules in the 1st component are
--- sorted by ascending index (order of creation). The algorithm has just six inference rules, specified as equations:
---
--- 1. The first rule simplifies the rule "MR" with smallest righthand side in the third component with ES UNION the CURRENT identity rules ES'
---    [since ES' rules can be simplified by generated rules of the form e => e' with e an identity element].  By giving to all identity elements
---    the SMALLEST order among all operators, we ensure that e' will also be an identity element. This simplification of MR
---    is done with "simpl-mrule(U,ES ES',MR)" (defined in file simplify-marked-term-and-rule.maude). If the result is trivial, it is
---    discarded; otherwise:
---
---    [i] the resulting simplified rule is numbered and added to:
---       a .the set of inter-reduced rules
---       b. if its lefthand side is an identity element, so the rule is e => e', then we must simplify with e => e' the lefthand sides
---          of ES' in the second component (with function left-simplified defined in file example-id.maude);
---       c. we must also add it to the equation set;
---       d.  If the top symbol is A or AC, we must also add it to the fourth component (IMRuleTable) that keeps also a table for A or AC rules; and
---
---    [ii] now the set "IMRL" of inter-reduced rules must be simplified by "simpl-mrule(U,ES ES',MR)".  This is done by starting a process as a
---    pair, which first component the results "reduce-imrules(U,simpl-mrule(U,ES ES',MR),IMRL)" (defined in file process.maude), and second
---    component the remaining unprocessed rules "MRL".
---
--- 2. The second rule is the case where rule [i] in "IMRL" was irreducible, so the result is discarded and nothing is done.
---
--- 3. The third rule is the case where the simplified rule [i] in "IMRL" became trivial, so it is removed from IMRL, ES and IMRT.
---
--- 4. The fourth rule is the case where the simplified rule [i] in "IMRL" was reducible and non-trivial, so that, besides
---    removing it from IMRL, ES and IMRT, it must be inserted in the sorted list of unprocessed rules "MRL" for further processing.
---
--- 5. In the fifth rule no unprocessed rules remain, and if m0 = j, a congruence closure has been reached. Then equations are returned;
---    for testing purposes the user-specified equations are simplified by the convergent rules (this is of course unnecessary).
---    Otherwise (m0 =/= j), there may still be rules whose critical pairs have not been computed.  To do so, a process is
---    started creating an "overlap list" with all the remaining index pairs for such critical pairs to be computed later.
---
--- 6. Such critical pairs are created one rule at a time by rule 6, overlapping each A or AC rule with itself and those with same
---    top symbol and having lower or equal index to the given rule.

fmod A\/C\/U-CONG-CLOSURE is
  pr CONG-CLOSURE-SHARED .

  op [_,_,_,_,_,_,_,_,_,_,_,_] : Module Term List{IMRule} EquationSet EquationSet IMRuleTable FAxiomSet List{OInfo<} Process Nat Nat Nat -> CCState .
  op [_,_,_] : EquationSet Nat GroundTerm -> CCState [ctor] .  --- final result with count of overlap cycles and test

  vars T T' T'' T''' TES : GroundTerm .  var ES ES' : EquationSet .  var AS : AttrSet . var FAS : FAxiomSet . var OL : List{OInfo<} .
  var OI : OInfo . vars i j n m k l m0 : Nat .  vars S S' S'' S''' : SetM{Qid} .  var f : Qid . var IMRT : IMRuleTable .
  var MR : MRule .  var IMR : IMRule .  var MRL : List{MRule<} . var IMRL : List{IMRule} . var RS : Results . var U : FModule .
  var H : Header . var IL : ImportList .

  op init-cc  : FModule Term -> CCState .
  op init-cc' : FModule FModule Term IMRuleTable FAxiomSet Process -> CCState .
  op id:eqs : -> EquationSet .
  op id:set : -> SetM{Qid} .
  op left-simplify : Equation EquationSet -> [EquationSet] .

  eq init-cc(U,TES) = [U,TES,nil,id:eqs,none,init-imrtab(U),init-faxset(U),nil,rules(U,TES),0,0,1] .

  eq [U,TES,IMRL,ES',ES,IMRT,FAS,OL,MR MRL,m0,k,j] =
       if simpl-mrule(U,ES ES',MR) == mt-mrule
          then [U,TES,IMRL,ES',ES,IMRT,FAS,OL,MRL,m0,k,j]
          else if ax top(left(simpl-mrule(U,ES ES',MR))) in FAS == free
                 then if top(left(simpl-mrule(U,ES ES',MR))) =< id:set == true
                         then [U,TES,IMRL ([j] simpl-mrule(U,ES ES',MR)),left-simplify(neweq(U,ES ES',MR,none),ES'),
                                neweq(U,ES ES',MR,j) ES,IMRT,FAS,OL,reduce-imrules(U,ES ES',MR,IMRL) # MRL,m0,k,s(j)]
                         else [U,TES,IMRL ([j] simpl-mrule(U,ES ES',MR)),ES',
                                neweq(U,ES ES',MR,j) ES,IMRT,FAS,OL,reduce-imrules(U,ES ES',MR,IMRL) # MRL,m0,k,s(j)]
                      fi
                 else [U,TES,IMRL ([j] simpl-mrule(U,ES ES',MR)),ES',neweq(U,ES ES',MR,j) ES,
                        add-imrule(top(left(simpl-mrule(U,ES ES',MR))),([j] simpl-mrule(U,ES ES',MR)),IMRT),
                        FAS,OL,reduce-imrules(U,ES ES',MR,IMRL) # MRL,m0,k,s(j)]
               fi
       fi .

  eq [U,TES,IMRL,ES',ES,IMRT,FAS,OL,{i} RS # MRL,m0,k,j] =
       [U,TES,IMRL,ES',ES,IMRT,FAS,OL,RS # MRL,m0,k,j] .

  eq [U,TES,IMRL,ES',ES,IMRT,FAS,OL,{f,[i] mt-mrule} RS # MRL,m0,k,j] =
       [U,TES,remove(i,IMRL),ES',rem-att(i,ES),remove([i,f],IMRT),FAS,OL, RS # MRL,m0,k,j] .

  eq [U,TES,IMRL,ES',ES,IMRT,FAS,OL,{f,[i] T [n,S] => T' [m,S']} RS # MRL,m0,k,j] =
       [U,TES,remove(i,IMRL),ES',rem-att(i,ES),remove([i,f],IMRT),FAS,OL,RS # ins(T [n,S] => T' [m,S'],MRL),m0,k,j] .

  eq [U,TES,IMRL,ES',ES,IMRT,FAS,nil,nil,m0,k,s(j)] =
       if m0 == j
          then [ES ES',k,reweqs(U,ES ES',TES)]
          else [U,TES,IMRL,ES',ES,IMRT,FAS,compute-overlaps(IMRT,m0),nil,j,s(k),s(j)]
       fi .

  eq [U,TES,IMRL,ES',ES,IMRT,FAS,OI OL,nil,m0,k,j] =
       [U,TES,IMRL,ES',ES,IMRT,FAS,OL,clean(sort(make-rule-map(U,CPS(U,OI,IMRT,FAS)))),m0,k,j] .
endfm
