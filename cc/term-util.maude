***(-----------------------------------------------------------------

Module      :  term-util
Stability   :  unstable
Portability :  portable

Some auxiliary functions on terms

---------------------------------------------------------------------)

fmod VARIABLE-SET is
  protecting META-LEVEL .
  protecting QID-SET * (op empty to none, op _,_ to _;_ [prec 43]) .
  protecting CONVERSION .

  var V  : Variable .
  var VS : QidSet .
  var Cs : Constant .
  var F  : Qid .
  var TL : TermList .
  var T  : Term .
  var NTL : NeTermList .
  vars I I' : Nat .

--- isVar - if it is variable or not
  op isVar : Variable -> Bool .
  eq isVar(V) = true .
  eq isVar(T) = false [owise] .

--- getVars - returns distinct vars of a term  
  op getVars : TermList -> QidSet . --- [memo] .
  eq getVars(V) = V .
  eq getVars(Cs) = none .
  eq getVars(F[NTL]) = getVars(NTL) .
  eq getVars(empty) = none .
  eq getVars((T , NTL)) = getVars(T) ; getVars(NTL) .

--- getVNumber - get N if variable is of the form V#N
  op getVNumber : Variable -> Nat . --- [memo] .
  eq getVNumber(V)
      = if (rfind(string(V), "#", 1) == notFound)
	then 0
        else rat(substr(string(getName(V)),2,length(string(getName(V)))),10)
        fi .

endfm

view Term from TRIV to META-TERM is sort Elt to Term .  endv

fmod TERM-POSITION is
  pr META-TERM .
  pr POSITION .
  pr 2TUPLE{Term,Position} * (sort Tuple{Term,Position} to TermPosition) .
endfm

view TermPosition from TRIV to TERM-POSITION is sort Elt to TermPosition .  endv

fmod TERM-POSITION-SET is
---  pr TERM-POSITION .
  pr SET{TermPosition} * ( sort Set{TermPosition} to TermPositionSet
	                 , sort NeSet{TermPosition} to NeTermPositionSet) .
endfm

view TermPositionSet from TRIV to TERM-POSITION-SET is sort Elt to TermPositionSet .  endv
view NeTermPositionSet from TRIV to TERM-POSITION-SET is sort Elt to NeTermPositionSet .  endv

view NeTermList from TRIV to META-TERM is sort Elt to NeTermList . endv

fmod NETL-NAT is
  pr 2TUPLE{NeTermList,Nat} * (sort Tuple{NeTermList,Nat} to NeTermListNat
                              ,  op ((_,_)) to ((_|_))) .

endfm

view NeTermListNat from TRIV to NETL-NAT is sort Elt to NeTermListNat . endv

fmod TERM-UTIL is
  pr VARIABLE-SET .
  pr TERM-POSITION-SET .
  pr NETL-NAT .
  pr TYPES-AUX .

  vars N N' N1 N2 N3 : Nat .  
  vars F Q : Qid .
  vars S S1 S2 S' Subst Subst' SUB : Substitution .
  var V : Variable .  
  var C : Constant .
  vars T T1 T2 : Term .  
  var TL : TermList .  
  vars NTL NTL1 NTL2 : NeTermList .
  var NV : NeQidSet .
  var P : Position .
  var ODS : OpDeclSet .
  var OD : OpDecl .
  vars Tp Tp1 Tp2 TpO : Type .
  var AttS : AttrSet .
  var M : Module .
  var QS : QidSet .
  var KOPDS : KindOpDeclSetSet .

  --- apply substitution ---
  op _<<_ : TermList Substitution -> TermList . --- [memo] .
  eq TL << none = TL .
  eq C << Subst = C .
  eq V << ((V <- T) ; Subst) = T .
  eq V << Subst = V [owise] .
  eq Q[TL] << Subst = Q[TL << Subst] .
  eq (T, NTL) << Subst = (T << Subst, NTL << Subst) .
  eq empty << Subst = empty .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V <- T) ; S') <<  S
   = (V <- (T << S)) ;(S' << S) .

  --- Rename each # variables in substitutions
  --- User input should not have variables starting with "#".
  op norm : Substitution -> Substitution .
  op norm : TermList -> TermList .
  eq norm((V <- T) ; Subst)    = V <- norm(T) ; norm(Subst) .
  eq norm((none).Substitution) = (none).Substitution .
  eq norm((T, NTL)) = norm(T), norm(NTL) .
  eq norm(Q[TL]) = Q[norm(TL)] .
  eq norm(empty) = empty .
  eq norm(C) = C .
  eq norm(V) = if substr(string(V), 0, 1) == "#" 
               then qid("V" + string(V)) else V fi .

--- getSubst --- match of two terms in the same theory
  op getSubst  : NeTermList NeTermList -> Substitution? . 
  eq getSubst(V, T) = V <- T .
  eq getSubst(C, C) = none .
  eq getSubst(F[NTL1], F[NTL2]) = getSubst(NTL1,NTL2) .
  eq getSubst((T1 , NTL1) , (T2 , NTL2)) = if getSubst(T1,T2) =/= noMatch and getSubst(NTL1,NTL2) =/= noMatch then getSubst(T1,T2) ; getSubst(NTL1,NTL2) else noMatch fi .
  eq getSubst(NTL1,NTL2) = noMatch [owise] .

--- fromSToCond
  op fromSToCond : QidSet -> Condition .
  eq fromSToCond(none) = nil .
  eq fromSToCond(V) = ('upTerm[V] = upTerm(V)) .
  eq fromSToCond((V ; NV)) = ('upTerm[V] = upTerm(V)) /\ fromSToCond(NV) .

--- nv-subterms - non-variable subterms
  op nvsubterms : NeTermList Position -> TermPositionSet . --- [memo] .
  eq nvsubterms(V, P) = (empty).TermPositionSet .
  eq nvsubterms(C, P) = (C, P) .
  eq nvsubterms(F[NTL], P) = (F[NTL], P) , nvsubterms(NTL, P . 1) .
  eq nvsubterms((T , NTL), P . N) = nvsubterms(T, P . N) , nvsubterms(NTL, P . s N) .

  --- flat - flat AC subterms
  op flat : Module NeTermList -> NeTermList . --- [memo] .
  eq flat(M, T1) = getTerm(metaNormalize(M, T1)) .

--- croot - returns the maximal constructor typing of the root symbol
--- if it exists. None otherwise.
  op croot : Module Term -> OpDeclSet .
  eq croot(M, F[NTL]) = root(M, F[NTL], getType(metaNormalize(M, F[NTL])), getOpsByKindAndQId(getMaximalTypings(M,getOpsByKind(M, (none).KindOpDeclSetSet, getCtors(getOps(M)))),getKind(M,getType(metaNormalize(M, F[NTL]))), F)) .
  eq croot(M, C) = constant-croot(M, C, getName(C), getType(C), getCtors(getOps(M))) .
  eq croot(M, T) = (none).OpDeclSet [owise] .

--- constant-croot - returns the maximal constructor typing of the root constant symbol
--- if it exists. None otherwise.
  op constant-croot : Module Term Qid Type OpDeclSet -> OpDeclSet .
  eq constant-croot(M, C, F, Tp, (op F : nil -> Tp [AttS] .) ODS) = (op F : nil -> Tp [AttS] .) .
  eq constant-croot(M, T, F, Tp, ODS) = (none).OpDeclSet [owise] .

--- root - returns the maximal typing of the root symbol if it
--- exists. None otherwise.
  op root : Module Term -> OpDeclSet .
  eq root(M, F[NTL]) = root(M, F[NTL], getType(metaNormalize(M, F[NTL])), getOpsByKindAndQId(getMaximalTypings(M,getOpsByKind(M, (none).KindOpDeclSetSet, getOps(M))),getKind(M,getType(metaNormalize(M, F[NTL]))), F)) .
  eq root(M, C) = constant-root(M, C, getName(C), getType(C), getOps(M)) .
  eq root(M, T) = (none).OpDeclSet [owise] .


--- constant-root - returns the maximal typing of the root constant symbol
--- if it exists. None otherwise.
  op constant-root : Module Term Qid Type OpDeclSet -> OpDeclSet .
  eq constant-root(M, C, F, Tp, (op F : nil -> Tp [AttS] .) ODS) = (op F : nil -> Tp [AttS] .) .
  eq constant-root(M, T, F, Tp, ODS) = (none).OpDeclSet [owise] .

--- replace-position - T|_P = T'
  op _[_](_) : Term Term Position -> Term .
  eq T1[T2](delta) = T2 .
  eq (Q[TL])[T](N . P) = Q[replace-position-list(TL, T, N . P)] .

--- replace-position-list - replace subterm of T by T' in a list.
  op replace-position-list : TermList Term Position -> Term .
  eq replace-position-list((T1, TL), T2, 1 . P) = T1[T2](P) , TL .
  eq replace-position-list((T1, TL), T2, (s s N) . P) = T1 , replace-position-list(TL, T2, (s N) . P) .

  --- mountACTerm - if the list of terms if greater than 1 then we
  --- mount an AC Term; if not, we return the term
  op mountACTerm : Qid NeTermList -> Term .
  eq mountACTerm(Q,T) = T .
  eq mountACTerm(Q,NTL) = Q[NTL] [owise] .

--- used for unification purposses to avoid renaming to variables in
--- use
  op getMaxV# : TermList -> Nat . --- [memo] .
  eq getMaxV#(V) = getVNumber(V) .
  eq getMaxV#(C) = 0 .
  eq getMaxV#(F[NTL]) = getMaxV#(NTL) .
  eq getMaxV#((empty).TermList) = 0 .
  eq getMaxV#((T , NTL)) = max(getMaxV#(T),getMaxV#(NTL)) .

  --- cap - renames terms headed by defined symbols and also return
  --- the next fresh variable number
  op cap : Module NeTermList Nat -> NeTermListNat . --- [memo] .
  eq cap(M, F[NTL], N) = cap-term(M, F[NTL], N, croot(M, F[NTL])) .
  eq cap(M, C, N) = cap-term(M, C, N, croot(M,C)) .
  eq cap(M, V, N) = (V | N) .
  eq cap(M, (T1 , NTL1), N1) = ((p1(cap(M, T1, N1)) , p1(cap(M, NTL1, p2(cap(M, T1, N1))))) | p2(cap(M, NTL1, p2(cap(M, T1, N1))))) .
    
  --- cap - renames term headed by defined symbols and also return
  --- the next fresh variable number
  op cap-term : Module Term Nat OpDeclSet -> NeTermListNat . --- [memo] .    
  eq cap-term(M, F[NTL], N, ODS)
    = if (ODS == (none).OpDeclSet)
      then (qid("V#" + string(s N,10) + ":" + string(leastSort(M,F[NTL]))) | s N)
      else (F[p1(cap(M,NTL,N))] | p2(cap(M,NTL,N)))
      fi .
  eq cap-term(M, C, N, ODS)
    = if (ODS == (none).OpDeclSet)
      then (qid("V#" + string(s N,10) + ":" + string(leastSort(M,C))) | s N)
      else (C | N)
      fi .
  eq cap-term(M, V, N, ODS) = (V | N) .

  op f-sorts : Module Qid -> TypeSet .
  eq f-sorts(M, F) = f-sorts(getOpsByQid(getCtors(getOps(M)), F)) .

  op f-sorts : OpDeclSet -> TypeSet .
  eq f-sorts((none).OpDeclSet) = (none).TypeSet .
  eq f-sorts((op F : Tp Tp -> Tp [assoc comm AttS] .) ODS) = Tp ; f-sorts(ODS) .
  eq f-sorts(ODS) = (none).TypeSet [owise] .
endfm

fmod OP-DECL-SET-UTIL is
  pr META-LEVEL .
 
  var Q : Qid .
  vars Tp Tp1 Tp2 TpO : Type .
  var AttS : AttrSet .
  var ODS : OpDeclSet .
  var OD : OpDecl .
  
  op isAC : OpDeclSet -> Bool .
  op getReturnType : OpDeclSet -> TypeSet .
  op length : OpDeclSet -> Nat .

  --- tell us if Q is an AC Symbol in the given OpDeclSet
  eq isAC((op Q : Tp1 Tp2 -> TpO [assoc comm AttS] .) ODS) = true .
  eq isAC(ODS) = false [owise] .

  --- getReturnType - give us the possible returning types of an AC
  --- symbol.
  eq getReturnType((op Q : Tp Tp -> Tp [assoc comm AttS] .) ODS) = Tp .
  eq getReturnType(ODS) = (none).TypeSet [owise] .

  --- lenght - number of operators
  eq length((none).OpDeclSet) = 0 .
  eq length(OD ODS) = 1 + length(ODS) .

endfm

fmod TERM-SET is
  protecting META-TERM .

 sorts NeTermSet TermSet .
  subsort Term < NeTermSet < TermSet .

  op mt  : -> TermSet [ctor] .
  op _o_ : TermSet TermSet -> TermSet [ctor assoc comm id: mt] .
  op _o_ : NeTermSet TermSet -> NeTermSet [ctor assoc comm id: mt] .

  var T  : Term .
  var TL : TermList .
  vars TS TS1 TS2 : TermSet .

  --- formTLToTS - from TermList to TermSet
  op fromTLToTS : TermList -> TermSet .
  eq fromTLToTS(empty)  = mt .
  eq fromTLToTS((T,TL)) = (T o fromTLToTS(TL)) .

  --- formTSToTL - from TermSet to TermList
  op fromTSToTL : TermSet -> TermList .
  eq fromTSToTL(mt)  = empty .
  eq fromTSToTL((T o TS)) = (T , fromTSToTL(TS)) .

  --- set-intersection - TermSet intersection
  op set-intersection : TermSet TermSet -> TermSet .
  eq set-intersection(T o TS1, T o TS2) = T o set-intersection(TS1, TS2) .
  eq set-intersection(TS1, TS2) = mt [owise] .

  --- set-difference - TermSet difference
  op set-difference : TermSet TermSet -> TermSet .
  eq set-difference((T o TS1), (T o TS2)) = set-difference(TS1, TS2) .
endfm
