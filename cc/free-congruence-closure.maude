*** free-congruence-closure.maude congruence closure algorithm with free symbols

***(The initial state "init" starts with the sorted list of marked rules generated by the equations specified by the user with constant
    "equations" in module U-EQ. Roughly, being sorted with smaller righthand sides first should ensure an O(n^2) complexity using hash-consing
    according to Plaisted-and-Sattler-Klein, but this algorithm is more eager than theirs, since rules are fully reduced by
    previous ones before being added to a set of inter-reduced rules.  The invariant kept by the algorithm is that the rules
    in the 1st component are always inter-reduced and therefore convergent (locally confluent, since no CPs exist, and
    terminating by construction).  This means that when no more equations remain in the third component we have reached the
    desired congruence closure.  The second component is a version of the convergent rules as a set of equations, to avoid
    recomputing that set for simplification purposes.  Another invariant is that the rules in the 1st component are
    sorted by ascending index (order of creation). The algorithm has just five equations:

    1. The first rule simplifies with "ES" the rule "MR" with smallest righthand side in the third component.  This
       is done with "simpl-mrule(ES,MR)" (defined in file simplify-marked-term-and-rule.maude). If the result is trivial, it is
       discarded; otherwise: (i) the resulting simplified rule is numbered and added to the set of inter-reduced rules and to the equation set; and
       (ii) now the set "IMRL" of inter-reduced rules must be simplified by "simpl-mrule(ES,MR)".  This is done by starting a process as a
       pair, which first component the results "reduce-imrules(simpl-mrule(ES,MR),IMRL)" (defined in file process.maude), and second
       component the remaining unprocessed rules "MRL".

    2. The second rule is the case where rule [i] in "IMRL" was irreducible, so the result is discarded and nothing is done.

    3. The third rule is the case where the simplified  rule [i] in "IMRL" became trivial, so it is removed from IMRL and ES.

    4. The fourth rule is the case where the simplified  rule [i] in "IMRL" was reducible and non-trivial, so that, besides
       removing it from IMRL and ES, it must be inserted in the sorted list of unprocessed rules "MRL" for further processing.

   5. In the fifth rule no unprocessed rules remain, so a congruence closure has been reached.  The equations are returned;
      for testing purposes the user-specified equations are simplified by the convergent rules (this is of course unnecessary).
)

fmod FREE-CONGRUENCE-CLOSURE is
  pr PROCESS .
  sort State .
  *** subsort EquationSet < State . *** could be used when test is removed

op [_,_,_,_] : List{IMRule} EquationSet Process Nat -> State .
op [_,_] : EquationSet GroundTerm -> State [ctor] .  *** final results with test

op init : -> State .

vars T T' T'' T''' : GroundTerm .  var ES : EquationSet .  var AS : AttrSet .
vars i j n m k l : Nat .  vars S S' S'' S''' : SetM{Qid} .  var f : Qid .
var MR : MRule .  var IMR : IMRule .  var MRL : List{MRule<} . var IMRL : List{IMRule} . var RS : Results .

op rem-att : AttrSet EquationSet -> EquationSet .  *** removes equation with attributes unique to the equation

eq rem-att(AS,(eq T = T' [AS] .) ES) = ES .
eq rem-att(AS,ES) = ES [owise] .

eq init = [nil,none,rules,1] .

eq [IMRL,ES,MR MRL,j] =
        if simpl-mrule(ES,MR) == mt-mrule
	   then [IMRL,ES,MRL,j]
	   else [IMRL ([j] simpl-mrule(ES,MR)),
	          eq left(simpl-mrule(ES,MR)) = right(simpl-mrule(ES,MR)) [metadata(string(j,10))] . ES,
		  reduce-imrules(simpl-mrule(ES,MR),IMRL) # MRL,s(j)]
	fi .

eq [IMRL,ES,{i} RS # MRL,j] = [IMRL,ES, RS # MRL,j] .
eq [IMRL,ES,{f,[i] mt-mrule} RS # MRL,j] = [remove(i,IMRL),rem-att(metadata(string(i,10)),ES), RS # MRL,j] .
eq [IMRL,ES,{f,[i] T [n,S] => T' [m,S']} RS # MRL,j] =
                                   [remove(i,IMRL),rem-att(metadata(string(i,10)),ES), RS # ins(T [n,S] => T' [m,S'],MRL),j] .

eq [IMRL,ES,nil,j] = [ES,getTerm(metaReduce(fmod 'TEST-RULES is including 'U-EQ .
		                          sorts none .
					  none
                                          none
					  none
					  ES
					  endfm,'equations.Eqs))] .
endfm

